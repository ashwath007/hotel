{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n/**\n * Gets all the child items for a specific parent item id. If the `recursive`\n * argument is enabled, all children of the items will also be returned instead\n * of only the top level items.\n *\n * @param data Either the flattened tree data or a list of all the tree data to\n * iterate over\n * @param parentId The parent id to get children of\n * @param recursive Boolean if the children's children should also be returned\n * @return a list of all the items for a specific parent item id. Note: if the\n * recursive param is enabled, the list will be ordered so that the children of\n * a item will appear before the next item at the same level. So you either need\n * to sort by `parentId` or something else if you want a specific order.\n */\n\n\nexport default function getChildItems(data, parentId, recursive) {\n  if (recursive === void 0) {\n    recursive = false;\n  }\n\n  var items = Array.isArray(data) ? data : Object.values(data);\n  return items.reduce(function (list, item) {\n    if (parentId !== item.parentId) {\n      return list;\n    }\n\n    return __spreadArrays(list, [item], recursive ? getChildItems(items, item.itemId, recursive) : []);\n  }, []);\n}","map":{"version":3,"sources":["../src/getChildItems.ts"],"names":[],"mappings":";;;;;;;AAEA;;;;;;;;;;;;;;;;AAcA,eAAc,SAAU,aAAV,CACZ,IADY,EAEZ,QAFY,EAGZ,SAHY,EAGc;AAA1B,MAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,SAAA,GAAA,KAAA;AAA0B;;AAE1B,MAAM,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,IAAd,IAAsB,IAAtB,GAA6B,MAAM,CAAC,MAAP,CAAc,IAAd,CAA3C;AAEA,SAAO,KAAK,CAAC,MAAN,CAAkB,UAAC,IAAD,EAAO,IAAP,EAAW;AAClC,QAAI,QAAQ,KAAK,IAAI,CAAC,QAAtB,EAAgC;AAC9B,aAAO,IAAP;AACD;;AAED,WAAA,cAAA,CACK,IADL,EACS,CACP,IADO,CADT,EAGM,SAAS,GAAG,aAAa,CAAC,KAAD,EAAQ,IAAI,CAAC,MAAb,EAAqB,SAArB,CAAhB,GAAkD,EAHjE,CAAA;AAKD,GAVM,EAUJ,EAVI,CAAP;AAWD","sourceRoot":"","sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * Gets all the child items for a specific parent item id. If the `recursive`\n * argument is enabled, all children of the items will also be returned instead\n * of only the top level items.\n *\n * @param data Either the flattened tree data or a list of all the tree data to\n * iterate over\n * @param parentId The parent id to get children of\n * @param recursive Boolean if the children's children should also be returned\n * @return a list of all the items for a specific parent item id. Note: if the\n * recursive param is enabled, the list will be ordered so that the children of\n * a item will appear before the next item at the same level. So you either need\n * to sort by `parentId` or something else if you want a specific order.\n */\nexport default function getChildItems(data, parentId, recursive) {\n    if (recursive === void 0) { recursive = false; }\n    var items = Array.isArray(data) ? data : Object.values(data);\n    return items.reduce(function (list, item) {\n        if (parentId !== item.parentId) {\n            return list;\n        }\n        return __spreadArrays(list, [\n            item\n        ], (recursive ? getChildItems(items, item.itemId, recursive) : []));\n    }, []);\n}\n//# sourceMappingURL=getChildItems.js.map"]},"metadata":{},"sourceType":"module"}