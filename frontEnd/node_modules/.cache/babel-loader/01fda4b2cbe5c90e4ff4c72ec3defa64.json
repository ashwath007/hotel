{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { useCallback, useRef } from \"react\";\nimport { JumpMovementKey, MovementPresets, useActiveDescendantMovement, scrollIntoView, useIsUserInteractionMode } from \"@react-md/utils\";\nimport useFlattenedTreeList from \"./useFlattenedTreeList\";\nimport useNestedTreeList from \"./useNestedTreeList\";\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @private\n */\n\nexport default function useTreeMovement(_a) {\n  var id = _a.id,\n      data = _a.data,\n      rootId = _a.rootId,\n      sort = _a.sort,\n      onBlur = _a.onBlur,\n      onFocus = _a.onFocus,\n      onKeyDown = _a.onKeyDown,\n      multiSelect = _a.multiSelect,\n      selectedIds = _a.selectedIds,\n      onItemSelect = _a.onItemSelect,\n      onMultiItemSelect = _a.onMultiItemSelect,\n      expandedIds = _a.expandedIds,\n      onItemExpansion = _a.onItemExpansion,\n      onMultiItemExpansion = _a.onMultiItemExpansion,\n      valueKey = _a.valueKey,\n      getItemValue = _a.getItemValue;\n  var items = useNestedTreeList(data, sort, rootId);\n\n  var _b = useFlattenedTreeList({\n    id: id,\n    items: items,\n    expandedIds: expandedIds,\n    rootId: rootId,\n    valueKey: valueKey,\n    getItemValue: getItemValue\n  }),\n      visibleItems = _b[0],\n      itemIdRefs = _b[1],\n      flattenedItems = _b[2];\n\n  var isKeyboard = useIsUserInteractionMode(\"keyboard\");\n\n  var _c = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_TREE), {\n    items: visibleItems,\n    baseId: id,\n    getId: function (_baseId, index) {\n      return (visibleItems[index] || {\n        id: \"\"\n      }).id;\n    },\n    onSpace: function (focusedIndex) {\n      var item = visibleItems[focusedIndex];\n\n      if (!item) {\n        return;\n      }\n\n      var itemId = item.itemId;\n      onItemSelect(itemId);\n    },\n    onChange: function (data) {\n      var index = data.index,\n          target = data.target,\n          query = data.query;\n      var itemId = visibleItems[index].itemId;\n      var item = itemIdRefs[itemId].ref.current;\n\n      if (item && target && target.scrollHeight > target.offsetHeight) {\n        scrollIntoView(target, item);\n      }\n\n      if (!multiSelect) {\n        return;\n      }\n\n      var isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n      var isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n\n      if (!isToStart && !isToEnd) {\n        return;\n      }\n\n      var start = isToStart ? 0 : focusedIndex;\n      var end = isToStart ? focusedIndex + 1 : undefined;\n      var jumpSelectedIds = visibleItems.slice(start, end).map(function (_a) {\n        var itemId = _a.itemId;\n        return itemId;\n      });\n      var uniqueSelectedIds = Array.from(new Set(__spreadArrays(selectedIds, jumpSelectedIds)));\n\n      if (selectedIds.length !== uniqueSelectedIds.length) {\n        onMultiItemSelect(uniqueSelectedIds);\n      }\n    },\n    onKeyDown: function (event) {\n      var _a, _b, _c, _d;\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      var item = visibleItems[focusedIndex];\n\n      if (!item) {\n        return;\n      }\n\n      var itemId = item.itemId,\n          parentId = item.parentId,\n          isParent = item.isParent;\n\n      switch (event.key) {\n        case \"Enter\":\n          {\n            if (isParent) {\n              onItemExpansion(itemId, !expandedIds.includes(itemId));\n              return;\n            }\n\n            var node = itemIdRefs[itemId].ref.current;\n            var anchor = node && node.getAttribute(\"role\") === \"none\" && node.querySelector(\"a[href]\");\n\n            if (!anchor) {\n              onItemSelect(itemId);\n              return;\n            } // if a user is navigating through the app with a keyboard and presses\n            // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n            // be forcefully opened in a new tab irregardless of the target\n            // attribute on the anchor tag. Since a tree doesn't actually focus\n            // the link in this case, need to \"polyfill\" it with this workaround.\n            // the `meta` key is for Mac and `ctrlKey` for Windows\n\n\n            var forceNewTab = event.shiftKey && (event.metaKey || event.ctrlKey);\n            var prevTarget = anchor.target;\n\n            if (forceNewTab) {\n              anchor.target = \"_blank\";\n            }\n\n            anchor.click();\n\n            if (forceNewTab) {\n              anchor.target = prevTarget;\n            }\n\n            break;\n          }\n\n        case \"ArrowRight\":\n          if (!isParent) {\n            return;\n          }\n\n          if (!expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, true);\n          } else {\n            var nextIndex = focusedIndex + 1;\n            var nextItem = (_b = itemIdRefs[(_a = visibleItems[nextIndex]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n            setFocusedIndex(nextIndex);\n            scrollIntoView(event.currentTarget, nextItem);\n          }\n\n          break;\n\n        case \"ArrowLeft\":\n          if (isParent && expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, false);\n          } else if (parentId !== rootId) {\n            var parentIndex = visibleItems.findIndex(function (item) {\n              return item.itemId === parentId;\n            });\n            var parentItem = (_d = itemIdRefs[(_c = visibleItems[parentIndex]) === null || _c === void 0 ? void 0 : _c.itemId]) === null || _d === void 0 ? void 0 : _d.ref.current;\n            setFocusedIndex(parentIndex);\n            scrollIntoView(event.currentTarget, parentItem);\n          }\n\n          break;\n\n        case \"a\":\n          {\n            if (!multiSelect || !event.ctrlKey) {\n              return;\n            }\n\n            event.preventDefault();\n            var allItemIds = visibleItems.map(function (_a) {\n              var itemId = _a.itemId;\n              return itemId;\n            });\n\n            if (selectedIds.length === allItemIds.length) {\n              onMultiItemSelect([]);\n            } else {\n              onMultiItemSelect(allItemIds);\n            }\n\n            break;\n          }\n\n        case \"*\":\n          {\n            var item_1 = visibleItems[focusedIndex];\n\n            if (!item_1) {\n              return;\n            }\n\n            var expectedExpandedIds = visibleItems.filter(function (_a) {\n              var isParent = _a.isParent,\n                  parentId = _a.parentId;\n              return isParent && parentId === item_1.parentId;\n            }).map(function (_a) {\n              var itemId = _a.itemId;\n              return itemId;\n            });\n            var nextIds = Array.from(new Set(__spreadArrays(expandedIds, expectedExpandedIds)));\n\n            if (nextIds.length !== expandedIds.length) {\n              onMultiItemExpansion(nextIds); // since new items will be rendered, need to also update the focused\n              // index so the currently active item is still the \"focused\" item\n              //\n              // TODO: Look into a much better way to handle this sort of stuff..\n              // This still doesn't correctly scroll the active element into view.\n              // I should probably move all the scroll behavior into a useEffect\n              // for whenever the focusedIndex changes.\n\n              var visibleCount = 0;\n              var lookup = {};\n\n              for (var i = 0; i < flattenedItems.length; i += 1) {\n                var item_2 = flattenedItems[i];\n                var isVisible = item_2.parentId === rootId;\n\n                if (item_2.parentId !== null && nextIds.includes(item_2.parentId)) {\n                  isVisible = !!lookup[item_2.parentId];\n                }\n\n                lookup[item_2.itemId] = isVisible;\n\n                if (itemId === item_2.itemId) {\n                  setFocusedIndex(visibleCount);\n                  return;\n                }\n\n                if (isVisible) {\n                  visibleCount += 1;\n                }\n              }\n            }\n          }\n        // no default\n      }\n    }\n  })),\n      activeId = _c.activeId,\n      handleKeyDown = _c.onKeyDown,\n      focusedIndex = _c.focusedIndex,\n      setFocusedIndex = _c.setFocusedIndex;\n\n  var lastFocus = useRef(0);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    if (document.activeElement && event.currentTarget.contains(document.activeElement)) {\n      return;\n    }\n\n    lastFocus.current = focusedIndex;\n    setFocusedIndex(-1);\n  }, [focusedIndex, onBlur, setFocusedIndex]);\n  var handleFocus = useCallback(function (event) {\n    var _a, _b;\n\n    if (onFocus) {\n      onFocus(event);\n    }\n\n    if (focusedIndex !== -1) {\n      // this happens when a tree item is clicked with the mouse or touch\n      return;\n    }\n\n    var index = -1; // try to \"focus\" the first selected itemId if there is a selection.\n\n    if (selectedIds.length) {\n      index = visibleItems.findIndex(function (item) {\n        return selectedIds.includes(item.itemId);\n      });\n    } // fallback to the first visible tree item if there were no selected ids\n\n\n    if (index === -1) {\n      index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n    }\n\n    var currentItem = (_b = itemIdRefs[(_a = visibleItems[index]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n\n    if (currentItem && isKeyboard) {\n      scrollIntoView(event.currentTarget, currentItem);\n    }\n\n    setFocusedIndex(index);\n  }, [focusedIndex, isKeyboard, itemIdRefs, onFocus, selectedIds, setFocusedIndex, visibleItems]);\n  var setActiveId = useCallback(function (itemId) {\n    var index = visibleItems.findIndex(function (item) {\n      return item.itemId === itemId;\n    });\n\n    if (index !== -1) {\n      setFocusedIndex(index);\n    }\n  }, [setFocusedIndex, visibleItems]);\n  return {\n    items: items,\n    activeId: activeId,\n    setActiveId: setActiveId,\n    itemIdRefs: itemIdRefs,\n    handleBlur: handleBlur,\n    handleFocus: handleFocus,\n    handleKeyDown: handleKeyDown\n  };\n}","map":{"version":3,"sources":["../src/useTreeMovement.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { useCallback, useRef, } from \"react\";\nimport { JumpMovementKey, MovementPresets, useActiveDescendantMovement, scrollIntoView, useIsUserInteractionMode, } from \"@react-md/utils\";\nimport useFlattenedTreeList from \"./useFlattenedTreeList\";\nimport useNestedTreeList from \"./useNestedTreeList\";\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @private\n */\nexport default function useTreeMovement(_a) {\n    var id = _a.id, data = _a.data, rootId = _a.rootId, sort = _a.sort, onBlur = _a.onBlur, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, multiSelect = _a.multiSelect, selectedIds = _a.selectedIds, onItemSelect = _a.onItemSelect, onMultiItemSelect = _a.onMultiItemSelect, expandedIds = _a.expandedIds, onItemExpansion = _a.onItemExpansion, onMultiItemExpansion = _a.onMultiItemExpansion, valueKey = _a.valueKey, getItemValue = _a.getItemValue;\n    var items = useNestedTreeList(data, sort, rootId);\n    var _b = useFlattenedTreeList({\n        id: id,\n        items: items,\n        expandedIds: expandedIds,\n        rootId: rootId,\n        valueKey: valueKey,\n        getItemValue: getItemValue,\n    }), visibleItems = _b[0], itemIdRefs = _b[1], flattenedItems = _b[2];\n    var isKeyboard = useIsUserInteractionMode(\"keyboard\");\n    var _c = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_TREE), { items: visibleItems, baseId: id, getId: function (_baseId, index) {\n            return (visibleItems[index] || { id: \"\" }).id;\n        },\n        onSpace: function (focusedIndex) {\n            var item = visibleItems[focusedIndex];\n            if (!item) {\n                return;\n            }\n            var itemId = item.itemId;\n            onItemSelect(itemId);\n        },\n        onChange: function (data) {\n            var index = data.index, target = data.target, query = data.query;\n            var itemId = visibleItems[index].itemId;\n            var item = itemIdRefs[itemId].ref.current;\n            if (item && target && target.scrollHeight > target.offsetHeight) {\n                scrollIntoView(target, item);\n            }\n            if (!multiSelect) {\n                return;\n            }\n            var isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n            var isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n            if (!isToStart && !isToEnd) {\n                return;\n            }\n            var start = isToStart ? 0 : focusedIndex;\n            var end = isToStart ? focusedIndex + 1 : undefined;\n            var jumpSelectedIds = visibleItems\n                .slice(start, end)\n                .map(function (_a) {\n                var itemId = _a.itemId;\n                return itemId;\n            });\n            var uniqueSelectedIds = Array.from(new Set(__spreadArrays(selectedIds, jumpSelectedIds)));\n            if (selectedIds.length !== uniqueSelectedIds.length) {\n                onMultiItemSelect(uniqueSelectedIds);\n            }\n        },\n        onKeyDown: function (event) {\n            var _a, _b, _c, _d;\n            if (onKeyDown) {\n                onKeyDown(event);\n            }\n            var item = visibleItems[focusedIndex];\n            if (!item) {\n                return;\n            }\n            var itemId = item.itemId, parentId = item.parentId, isParent = item.isParent;\n            switch (event.key) {\n                case \"Enter\": {\n                    if (isParent) {\n                        onItemExpansion(itemId, !expandedIds.includes(itemId));\n                        return;\n                    }\n                    var node = itemIdRefs[itemId].ref.current;\n                    var anchor = node &&\n                        node.getAttribute(\"role\") === \"none\" &&\n                        node.querySelector(\"a[href]\");\n                    if (!anchor) {\n                        onItemSelect(itemId);\n                        return;\n                    }\n                    // if a user is navigating through the app with a keyboard and presses\n                    // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n                    // be forcefully opened in a new tab irregardless of the target\n                    // attribute on the anchor tag. Since a tree doesn't actually focus\n                    // the link in this case, need to \"polyfill\" it with this workaround.\n                    // the `meta` key is for Mac and `ctrlKey` for Windows\n                    var forceNewTab = event.shiftKey && (event.metaKey || event.ctrlKey);\n                    var prevTarget = anchor.target;\n                    if (forceNewTab) {\n                        anchor.target = \"_blank\";\n                    }\n                    anchor.click();\n                    if (forceNewTab) {\n                        anchor.target = prevTarget;\n                    }\n                    break;\n                }\n                case \"ArrowRight\":\n                    if (!isParent) {\n                        return;\n                    }\n                    if (!expandedIds.includes(itemId)) {\n                        onItemExpansion(itemId, true);\n                    }\n                    else {\n                        var nextIndex = focusedIndex + 1;\n                        var nextItem = (_b = itemIdRefs[(_a = visibleItems[nextIndex]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n                        setFocusedIndex(nextIndex);\n                        scrollIntoView(event.currentTarget, nextItem);\n                    }\n                    break;\n                case \"ArrowLeft\":\n                    if (isParent && expandedIds.includes(itemId)) {\n                        onItemExpansion(itemId, false);\n                    }\n                    else if (parentId !== rootId) {\n                        var parentIndex = visibleItems.findIndex(function (item) { return item.itemId === parentId; });\n                        var parentItem = (_d = itemIdRefs[(_c = visibleItems[parentIndex]) === null || _c === void 0 ? void 0 : _c.itemId]) === null || _d === void 0 ? void 0 : _d.ref.current;\n                        setFocusedIndex(parentIndex);\n                        scrollIntoView(event.currentTarget, parentItem);\n                    }\n                    break;\n                case \"a\": {\n                    if (!multiSelect || !event.ctrlKey) {\n                        return;\n                    }\n                    event.preventDefault();\n                    var allItemIds = visibleItems.map(function (_a) {\n                        var itemId = _a.itemId;\n                        return itemId;\n                    });\n                    if (selectedIds.length === allItemIds.length) {\n                        onMultiItemSelect([]);\n                    }\n                    else {\n                        onMultiItemSelect(allItemIds);\n                    }\n                    break;\n                }\n                case \"*\": {\n                    var item_1 = visibleItems[focusedIndex];\n                    if (!item_1) {\n                        return;\n                    }\n                    var expectedExpandedIds = visibleItems\n                        .filter(function (_a) {\n                        var isParent = _a.isParent, parentId = _a.parentId;\n                        return isParent && parentId === item_1.parentId;\n                    })\n                        .map(function (_a) {\n                        var itemId = _a.itemId;\n                        return itemId;\n                    });\n                    var nextIds = Array.from(new Set(__spreadArrays(expandedIds, expectedExpandedIds)));\n                    if (nextIds.length !== expandedIds.length) {\n                        onMultiItemExpansion(nextIds);\n                        // since new items will be rendered, need to also update the focused\n                        // index so the currently active item is still the \"focused\" item\n                        //\n                        // TODO: Look into a much better way to handle this sort of stuff..\n                        // This still doesn't correctly scroll the active element into view.\n                        // I should probably move all the scroll behavior into a useEffect\n                        // for whenever the focusedIndex changes.\n                        var visibleCount = 0;\n                        var lookup = {};\n                        for (var i = 0; i < flattenedItems.length; i += 1) {\n                            var item_2 = flattenedItems[i];\n                            var isVisible = item_2.parentId === rootId;\n                            if (item_2.parentId !== null && nextIds.includes(item_2.parentId)) {\n                                isVisible = !!lookup[item_2.parentId];\n                            }\n                            lookup[item_2.itemId] = isVisible;\n                            if (itemId === item_2.itemId) {\n                                setFocusedIndex(visibleCount);\n                                return;\n                            }\n                            if (isVisible) {\n                                visibleCount += 1;\n                            }\n                        }\n                    }\n                }\n                // no default\n            }\n        } })), activeId = _c.activeId, handleKeyDown = _c.onKeyDown, focusedIndex = _c.focusedIndex, setFocusedIndex = _c.setFocusedIndex;\n    var lastFocus = useRef(0);\n    var handleBlur = useCallback(function (event) {\n        if (onBlur) {\n            onBlur(event);\n        }\n        if (document.activeElement &&\n            event.currentTarget.contains(document.activeElement)) {\n            return;\n        }\n        lastFocus.current = focusedIndex;\n        setFocusedIndex(-1);\n    }, [focusedIndex, onBlur, setFocusedIndex]);\n    var handleFocus = useCallback(function (event) {\n        var _a, _b;\n        if (onFocus) {\n            onFocus(event);\n        }\n        if (focusedIndex !== -1) {\n            // this happens when a tree item is clicked with the mouse or touch\n            return;\n        }\n        var index = -1;\n        // try to \"focus\" the first selected itemId if there is a selection.\n        if (selectedIds.length) {\n            index = visibleItems.findIndex(function (item) {\n                return selectedIds.includes(item.itemId);\n            });\n        }\n        // fallback to the first visible tree item if there were no selected ids\n        if (index === -1) {\n            index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n        }\n        var currentItem = (_b = itemIdRefs[(_a = visibleItems[index]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n        if (currentItem && isKeyboard) {\n            scrollIntoView(event.currentTarget, currentItem);\n        }\n        setFocusedIndex(index);\n    }, [\n        focusedIndex,\n        isKeyboard,\n        itemIdRefs,\n        onFocus,\n        selectedIds,\n        setFocusedIndex,\n        visibleItems,\n    ]);\n    var setActiveId = useCallback(function (itemId) {\n        var index = visibleItems.findIndex(function (item) { return item.itemId === itemId; });\n        if (index !== -1) {\n            setFocusedIndex(index);\n        }\n    }, [setFocusedIndex, visibleItems]);\n    return {\n        items: items,\n        activeId: activeId,\n        setActiveId: setActiveId,\n        itemIdRefs: itemIdRefs,\n        handleBlur: handleBlur,\n        handleFocus: handleFocus,\n        handleKeyDown: handleKeyDown,\n    };\n}\n//# sourceMappingURL=useTreeMovement.js.map"]},"metadata":{},"sourceType":"module"}