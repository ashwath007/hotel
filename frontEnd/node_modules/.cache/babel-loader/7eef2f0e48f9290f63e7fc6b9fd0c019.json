{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { Children, isValidElement, useCallback, useEffect, useMemo, useState } from \"react\";\nimport { MovementPresets, useKeyboardMovement } from \"@react-md/utils\";\n/**\n * @private\n */\n\nexport default function useTabsMovement(_a) {\n  var onClick = _a.onClick,\n      onKeyDown = _a.onKeyDown,\n      children = _a.children,\n      automatic = _a.automatic,\n      horizontal = _a.horizontal,\n      activeIndex = _a.activeIndex,\n      onActiveIndexChange = _a.onActiveIndexChange; // first filter out all \"nulled\" or falsish elements since it's possible to do:\n  // {!thing && <Tab />}\n\n  var tabs = useMemo(function () {\n    return Children.toArray(children).filter(Boolean);\n  }, [children]); // now filter out any other invalid elements (text nodes for some reason) and\n  // disabled tabs since they shouldn't be keyboard focusable\n\n  var visibleTabs = useMemo(function () {\n    return tabs.filter(function (child) {\n      return isValidElement(child) && !child.props.disabled;\n    });\n  }, [tabs]);\n\n  var _b = useState(activeIndex),\n      focusedIndex = _b[0],\n      setFocusedIndex = _b[1];\n\n  useEffect(function () {\n    setFocusedIndex(activeIndex);\n  }, [activeIndex]);\n\n  var _c = useKeyboardMovement(__assign(__assign({}, horizontal ? MovementPresets.HORIZONTAL_TABS : MovementPresets.VERTICAL_TABS), {\n    onKeyDown: onKeyDown,\n    focusedIndex: focusedIndex,\n    items: visibleTabs,\n    onChange: function (_a) {\n      var index = _a.index;\n\n      if (index === -1) {\n        return;\n      }\n\n      if (automatic) {\n        onActiveIndexChange(index);\n      }\n\n      var item = itemRefs[index] && itemRefs[index].current;\n\n      if (item) {\n        item.focus();\n      }\n\n      setFocusedIndex(index);\n    }\n  })),\n      itemRefs = _c[0],\n      handleKeyDown = _c[1];\n\n  var handleClick = useCallback(function (event) {\n    if (onClick) {\n      onClick(event);\n    }\n\n    var target = event.target && event.target.closest(\"button\");\n\n    if (!target) {\n      return;\n    }\n\n    var index = itemRefs.findIndex(function (ref) {\n      return ref.current === target;\n    });\n\n    if (activeIndex !== index) {\n      onActiveIndexChange(index);\n    }\n  }, [activeIndex, itemRefs, onActiveIndexChange, onClick]);\n  return {\n    tabs: tabs,\n    itemRefs: itemRefs,\n    handleClick: handleClick,\n    handleKeyDown: handleKeyDown\n  };\n}","map":{"version":3,"sources":["../src/useTabsMovement.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { Children, isValidElement, useCallback, useEffect, useMemo, useState, } from \"react\";\nimport { MovementPresets, useKeyboardMovement, } from \"@react-md/utils\";\n/**\n * @private\n */\nexport default function useTabsMovement(_a) {\n    var onClick = _a.onClick, onKeyDown = _a.onKeyDown, children = _a.children, automatic = _a.automatic, horizontal = _a.horizontal, activeIndex = _a.activeIndex, onActiveIndexChange = _a.onActiveIndexChange;\n    // first filter out all \"nulled\" or falsish elements since it's possible to do:\n    // {!thing && <Tab />}\n    var tabs = useMemo(function () { return Children.toArray(children).filter(Boolean); }, [\n        children,\n    ]);\n    // now filter out any other invalid elements (text nodes for some reason) and\n    // disabled tabs since they shouldn't be keyboard focusable\n    var visibleTabs = useMemo(function () {\n        return tabs.filter(function (child) { return isValidElement(child) && !child.props.disabled; });\n    }, [tabs]);\n    var _b = useState(activeIndex), focusedIndex = _b[0], setFocusedIndex = _b[1];\n    useEffect(function () {\n        setFocusedIndex(activeIndex);\n    }, [activeIndex]);\n    var _c = useKeyboardMovement(__assign(__assign({}, (horizontal\n        ? MovementPresets.HORIZONTAL_TABS\n        : MovementPresets.VERTICAL_TABS)), { onKeyDown: onKeyDown,\n        focusedIndex: focusedIndex, items: visibleTabs, onChange: function (_a) {\n            var index = _a.index;\n            if (index === -1) {\n                return;\n            }\n            if (automatic) {\n                onActiveIndexChange(index);\n            }\n            var item = itemRefs[index] && itemRefs[index].current;\n            if (item) {\n                item.focus();\n            }\n            setFocusedIndex(index);\n        } })), itemRefs = _c[0], handleKeyDown = _c[1];\n    var handleClick = useCallback(function (event) {\n        if (onClick) {\n            onClick(event);\n        }\n        var target = event.target && event.target.closest(\"button\");\n        if (!target) {\n            return;\n        }\n        var index = itemRefs.findIndex(function (ref) { return ref.current === target; });\n        if (activeIndex !== index) {\n            onActiveIndexChange(index);\n        }\n    }, [activeIndex, itemRefs, onActiveIndexChange, onClick]);\n    return {\n        tabs: tabs,\n        itemRefs: itemRefs,\n        handleClick: handleClick,\n        handleKeyDown: handleKeyDown,\n    };\n}\n//# sourceMappingURL=useTabsMovement.js.map"]},"metadata":{},"sourceType":"module"}