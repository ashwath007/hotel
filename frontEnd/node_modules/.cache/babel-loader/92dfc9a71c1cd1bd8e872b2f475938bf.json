{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { useMemo } from \"react\";\nimport getTreeItemId from \"./getTreeItemId\";\n\nfunction flatten(_a) {\n  var list = _a.list,\n      item = _a.item,\n      index = _a.index,\n      baseId = _a.baseId,\n      parentIndexes = _a.parentIndexes,\n      valueKey = _a.valueKey,\n      getItemValue = _a.getItemValue;\n\n  if (item.isCustom) {\n    return list;\n  }\n\n  var id = getTreeItemId(baseId, index, parentIndexes);\n  var value = getItemValue(item, valueKey);\n  var itemId = item.itemId,\n      parentId = item.parentId,\n      childItems = item.childItems;\n  list.push({\n    id: id,\n    itemId: itemId,\n    parentId: parentId,\n    isParent: !!childItems,\n    value: value\n  });\n\n  if (!childItems) {\n    return list;\n  }\n\n  var nextIndexes = __spreadArrays(parentIndexes, [index + 1]);\n\n  childItems.forEach(function (child, childIndex) {\n    flatten({\n      list: list,\n      item: child,\n      index: childIndex,\n      valueKey: valueKey,\n      getItemValue: getItemValue,\n      baseId: baseId,\n      parentIndexes: nextIndexes\n    });\n  });\n  return list;\n}\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @private\n */\n\n\nexport default function useFlattenedTreeList(_a) {\n  var id = _a.id,\n      items = _a.items,\n      rootId = _a.rootId,\n      expandedIds = _a.expandedIds,\n      valueKey = _a.valueKey,\n      getItemValue = _a.getItemValue;\n  var flattenedItems = useMemo(function () {\n    return items.reduce(function (list, item, index) {\n      return flatten({\n        list: list,\n        item: item,\n        index: index,\n        valueKey: valueKey,\n        getItemValue: getItemValue,\n        baseId: id,\n        parentIndexes: []\n      });\n    }, []);\n  }, [getItemValue, id, items, valueKey]);\n\n  var _b = useMemo(function () {\n    var index = 0;\n    return flattenedItems.reduce(function (collection, item) {\n      var _a, _b;\n\n      var parentId = item.parentId,\n          itemId = item.itemId;\n      var isVisible = parentId === rootId;\n\n      if (parentId !== null && expandedIds.includes(parentId)) {\n        // need to also make sure that the parent is visible\n        isVisible = ((_b = (_a = collection.itemRefs[parentId]) === null || _a === void 0 ? void 0 : _a.visibleIndex) !== null && _b !== void 0 ? _b : -1) !== -1;\n      }\n\n      collection.itemRefs[itemId] = {\n        id: item.id,\n        ref: {\n          current: null\n        },\n        visibleIndex: isVisible ? index : -1\n      };\n\n      if (isVisible) {\n        index += 1;\n        collection.visibleItems.push(item);\n      }\n\n      return collection;\n    }, {\n      visibleItems: [],\n      itemRefs: {}\n    });\n  }, [expandedIds, flattenedItems, rootId]),\n      visibleItems = _b.visibleItems,\n      itemRefs = _b.itemRefs;\n\n  return [visibleItems, itemRefs, flattenedItems];\n}","map":{"version":3,"sources":["../src/useFlattenedTreeList.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { useMemo } from \"react\";\nimport getTreeItemId from \"./getTreeItemId\";\nfunction flatten(_a) {\n    var list = _a.list, item = _a.item, index = _a.index, baseId = _a.baseId, parentIndexes = _a.parentIndexes, valueKey = _a.valueKey, getItemValue = _a.getItemValue;\n    if (item.isCustom) {\n        return list;\n    }\n    var id = getTreeItemId(baseId, index, parentIndexes);\n    var value = getItemValue(item, valueKey);\n    var itemId = item.itemId, parentId = item.parentId, childItems = item.childItems;\n    list.push({\n        id: id,\n        itemId: itemId,\n        parentId: parentId,\n        isParent: !!childItems,\n        value: value,\n    });\n    if (!childItems) {\n        return list;\n    }\n    var nextIndexes = __spreadArrays(parentIndexes, [index + 1]);\n    childItems.forEach(function (child, childIndex) {\n        flatten({\n            list: list,\n            item: child,\n            index: childIndex,\n            valueKey: valueKey,\n            getItemValue: getItemValue,\n            baseId: baseId,\n            parentIndexes: nextIndexes,\n        });\n    });\n    return list;\n}\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @private\n */\nexport default function useFlattenedTreeList(_a) {\n    var id = _a.id, items = _a.items, rootId = _a.rootId, expandedIds = _a.expandedIds, valueKey = _a.valueKey, getItemValue = _a.getItemValue;\n    var flattenedItems = useMemo(function () {\n        return items.reduce(function (list, item, index) {\n            return flatten({\n                list: list,\n                item: item,\n                index: index,\n                valueKey: valueKey,\n                getItemValue: getItemValue,\n                baseId: id,\n                parentIndexes: [],\n            });\n        }, []);\n    }, [getItemValue, id, items, valueKey]);\n    var _b = useMemo(function () {\n        var index = 0;\n        return flattenedItems.reduce(function (collection, item) {\n            var _a, _b;\n            var parentId = item.parentId, itemId = item.itemId;\n            var isVisible = parentId === rootId;\n            if (parentId !== null && expandedIds.includes(parentId)) {\n                // need to also make sure that the parent is visible\n                isVisible =\n                    ((_b = (_a = collection.itemRefs[parentId]) === null || _a === void 0 ? void 0 : _a.visibleIndex) !== null && _b !== void 0 ? _b : -1) !== -1;\n            }\n            collection.itemRefs[itemId] = {\n                id: item.id,\n                ref: { current: null },\n                visibleIndex: isVisible ? index : -1,\n            };\n            if (isVisible) {\n                index += 1;\n                collection.visibleItems.push(item);\n            }\n            return collection;\n        }, { visibleItems: [], itemRefs: {} });\n    }, [expandedIds, flattenedItems, rootId]), visibleItems = _b.visibleItems, itemRefs = _b.itemRefs;\n    return [visibleItems, itemRefs, flattenedItems];\n}\n//# sourceMappingURL=useFlattenedTreeList.js.map"]},"metadata":{},"sourceType":"module"}