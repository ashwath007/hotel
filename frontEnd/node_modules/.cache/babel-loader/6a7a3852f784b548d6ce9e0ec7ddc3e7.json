{"ast":null,"code":"import { caseInsensitiveFilter, fuzzyFilter } from \"@react-md/utils\";\n/**\n * Generates an id for each result in the autocomplete's listbox.\n *\n * @param id The listbox's id\n * @param index The index of the result in the list\n * @return an id string\n */\n\nexport function getResultId(id, index) {\n  return id + \"-result-\" + (index + 1);\n}\n/**\n * Gets a renderable label for each result in the autocomplete's listbox. This\n * will be applied as the `children` for the `Option` element.\n *\n * @param datum The current result datum to get a label for\n * @param labelKey The key to extract a label from if the datum is an object\n * @param query The current search query. This is useful if you want to\n * implement text \"highlighting\" (bold) of all the letters that match in the\n * item.\n * @return a renderable node to display\n */\n\nexport function getResultLabel(datum, labelKey, _query) {\n  if (typeof datum === \"string\") {\n    return datum;\n  }\n\n  var label = datum[labelKey];\n  return datum.children || (typeof label === \"undefined\" ? null : label);\n}\n/**\n * Gets a value string from each result that can be searched.\n *\n * @param datum The current result datum that should have a string extracted\n * @param valueKey The key to use to extract a string value from if the datum is\n * an object\n * @return a searchable string.\n */\n\nexport function getResultValue(datum, valueKey) {\n  if (typeof datum === \"string\") {\n    return datum;\n  }\n\n  var value = datum[valueKey];\n\n  if (process.env.NODE_ENV !== \"production\" && typeof value !== \"string\" && typeof value !== \"number\") {\n    throw new Error(\"Unable to extract a result value string\");\n  }\n\n  return \"\" + value;\n}\n/**\n * This is used to disable filtering and just return the data list immediately.\n * Useful when the filtering is done somewhere else like a server/API\n * @private\n */\n\nexport var noFilter = function (_, data) {\n  return data;\n};\n/**\n * Gets the filter function to use within the Autocomplete based on the provided\n * filter prop\n *\n * @private\n */\n\nexport function getFilterFunction(filter) {\n  if (typeof filter === \"function\") {\n    return filter;\n  }\n\n  switch (filter) {\n    case \"fuzzy\":\n      return fuzzyFilter;\n\n    case \"case-insensitive\":\n      return caseInsensitiveFilter;\n\n    case \"none\":\n      return noFilter;\n\n    default:\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error(\"Invalid filter function: \\\"\" + filter + \"\\\". Supported values are: \\\"fuzzy\\\", \\\"case-insenitive\\\", \\\"none\\\", or a custom function.\");\n      }\n\n      return noFilter;\n  }\n}\n/**\n * This is an extremely simple type guard that is useful when using the\n * `onAutoComplete` handler since I'm terrible at typescript types. This will\n * ensure that if the result is an object, it will match the provided data type\n * of your data list.\n *\n * Example:\n *\n * ```ts\n * interface Example {\n *   name: string;\n *   value: string;\n * }\n *\n *\n * const [example, setExample] = useState<Example | null>(null);\n * const onAutoComplete = useCallback<AuoCompleteHandler>((_name, example) => {\n *   if (isResultOf<Example>(example)) {\n *     setExample(example);\n *   }\n * }, [])\n * ```\n *\n * @param datum The result data to type guard against.\n */\n\nexport function isResultOf(datum) {\n  return !!datum && typeof datum === \"object\";\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"AACA,SAAS,qBAAT,EAAgC,WAAhC,QAAmD,iBAAnD;AAQA;;;;;;;;AAOA,OAAM,SAAU,WAAV,CAAsB,EAAtB,EAAkC,KAAlC,EAA+C;AACnD,SAAU,EAAE,GAAA,UAAF,IAAa,KAAK,GAAG,CAArB,CAAV;AACD;AAED;;;;;;;;;;;;AAWA,OAAM,SAAU,cAAV,CACJ,KADI,EAEJ,QAFI,EAGJ,MAHI,EAGU;AAEd,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAO,KAAP;AACD;;AAED,MAAM,KAAK,GAAG,KAAK,CAAC,QAAD,CAAnB;AACA,SAAO,KAAK,CAAC,QAAN,KAAmB,OAAO,KAAP,KAAiB,WAAjB,GAA+B,IAA/B,GAAsC,KAAzD,CAAP;AACD;AAED;;;;;;;;;AAQA,OAAM,SAAU,cAAV,CACJ,KADI,EAEJ,QAFI,EAEY;AAEhB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAO,KAAP;AACD;;AAED,MAAM,KAAK,GAAG,KAAK,CAAC,QAAD,CAAnB;;AACA,MACE,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAAzB,IACA,OAAO,KAAP,KAAiB,QADjB,IAEA,OAAO,KAAP,KAAiB,QAHnB,EAIE;AACA,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,SAAO,KAAG,KAAV;AACD;AAED;;;;;;AAKA,OAAO,IAAM,QAAQ,GAAmB,UAAC,CAAD,EAAI,IAAJ,EAAQ;AAAK,SAAA,IAAA;AAAI,CAAlD;AAEP;;;;;;;AAMA,OAAM,SAAU,iBAAV,CACJ,MADI,EACiC;AAErC,MAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAChC,WAAO,MAAP;AACD;;AAED,UAAQ,MAAR;AACE,SAAK,OAAL;AACE,aAAO,WAAP;;AACF,SAAK,kBAAL;AACE,aAAO,qBAAP;;AACF,SAAK,MAAL;AACE,aAAO,QAAP;;AACF;AACE,UAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,cAAM,IAAI,KAAJ,CACJ,gCAA6B,MAA7B,GAAmC,2FAD/B,CAAN;AAGD;;AAED,aAAO,QAAP;AAdJ;AAgBD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAM,SAAU,UAAV,CACJ,KADI,EAC6B;AAEjC,SAAO,CAAC,CAAC,KAAF,IAAW,OAAO,KAAP,KAAiB,QAAnC;AACD","sourceRoot":"","sourcesContent":["import { caseInsensitiveFilter, fuzzyFilter } from \"@react-md/utils\";\n/**\n * Generates an id for each result in the autocomplete's listbox.\n *\n * @param id The listbox's id\n * @param index The index of the result in the list\n * @return an id string\n */\nexport function getResultId(id, index) {\n    return id + \"-result-\" + (index + 1);\n}\n/**\n * Gets a renderable label for each result in the autocomplete's listbox. This\n * will be applied as the `children` for the `Option` element.\n *\n * @param datum The current result datum to get a label for\n * @param labelKey The key to extract a label from if the datum is an object\n * @param query The current search query. This is useful if you want to\n * implement text \"highlighting\" (bold) of all the letters that match in the\n * item.\n * @return a renderable node to display\n */\nexport function getResultLabel(datum, labelKey, _query) {\n    if (typeof datum === \"string\") {\n        return datum;\n    }\n    var label = datum[labelKey];\n    return datum.children || (typeof label === \"undefined\" ? null : label);\n}\n/**\n * Gets a value string from each result that can be searched.\n *\n * @param datum The current result datum that should have a string extracted\n * @param valueKey The key to use to extract a string value from if the datum is\n * an object\n * @return a searchable string.\n */\nexport function getResultValue(datum, valueKey) {\n    if (typeof datum === \"string\") {\n        return datum;\n    }\n    var value = datum[valueKey];\n    if (process.env.NODE_ENV !== \"production\" &&\n        typeof value !== \"string\" &&\n        typeof value !== \"number\") {\n        throw new Error(\"Unable to extract a result value string\");\n    }\n    return \"\" + value;\n}\n/**\n * This is used to disable filtering and just return the data list immediately.\n * Useful when the filtering is done somewhere else like a server/API\n * @private\n */\nexport var noFilter = function (_, data) { return data; };\n/**\n * Gets the filter function to use within the Autocomplete based on the provided\n * filter prop\n *\n * @private\n */\nexport function getFilterFunction(filter) {\n    if (typeof filter === \"function\") {\n        return filter;\n    }\n    switch (filter) {\n        case \"fuzzy\":\n            return fuzzyFilter;\n        case \"case-insensitive\":\n            return caseInsensitiveFilter;\n        case \"none\":\n            return noFilter;\n        default:\n            if (process.env.NODE_ENV !== \"production\") {\n                throw new Error(\"Invalid filter function: \\\"\" + filter + \"\\\". Supported values are: \\\"fuzzy\\\", \\\"case-insenitive\\\", \\\"none\\\", or a custom function.\");\n            }\n            return noFilter;\n    }\n}\n/**\n * This is an extremely simple type guard that is useful when using the\n * `onAutoComplete` handler since I'm terrible at typescript types. This will\n * ensure that if the result is an object, it will match the provided data type\n * of your data list.\n *\n * Example:\n *\n * ```ts\n * interface Example {\n *   name: string;\n *   value: string;\n * }\n *\n *\n * const [example, setExample] = useState<Example | null>(null);\n * const onAutoComplete = useCallback<AuoCompleteHandler>((_name, example) => {\n *   if (isResultOf<Example>(example)) {\n *     setExample(example);\n *   }\n * }, [])\n * ```\n *\n * @param datum The result data to type guard against.\n */\nexport function isResultOf(datum) {\n    return !!datum && typeof datum === \"object\";\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}