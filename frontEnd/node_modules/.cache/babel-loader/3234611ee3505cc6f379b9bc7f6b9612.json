{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React, { forwardRef, useRef } from \"react\";\nimport cn from \"classnames\";\nimport { DEFAULT_SHEET_TIMEOUT } from \"@react-md/sheet\";\nimport { useCSSTransition } from \"@react-md/transition\";\nimport { bem, useIsUserInteractionMode } from \"@react-md/utils\";\nimport { DEFAULT_LAYOUT_MAIN_CLASSNAMES } from \"./constants\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { isTemporaryLayout } from \"./utils\";\nvar styles = bem(\"rmd-layout-main\");\n/**\n * This is the `<main>` element for your app that has some built in styles to be\n * able to update based on the current layout types.\n */\n\nvar LayoutMain = forwardRef(function LayoutMain(_a, forwardedRef) {\n  var propClassName = _a.className,\n      propTabIndex = _a.tabIndex,\n      _b = _a.component,\n      Component = _b === void 0 ? \"main\" : _b,\n      propNavOffset = _a.navOffset,\n      _c = _a.headerOffset,\n      headerOffset = _c === void 0 ? false : _c,\n      _d = _a.timeout,\n      propTimeout = _d === void 0 ? DEFAULT_SHEET_TIMEOUT : _d,\n      _e = _a.classNames,\n      classNames = _e === void 0 ? DEFAULT_LAYOUT_MAIN_CLASSNAMES : _e,\n      props = __rest(_a, [\"className\", \"tabIndex\", \"component\", \"navOffset\", \"headerOffset\", \"timeout\", \"classNames\"]); // this makes it so that the SkipToMainContent button can still\n  // focus the `<main>` element, but the `<main>` will no longer be\n  // focused if the user clicks inside. This is super nice since one\n  // of my bigger patterns is to click somewhere then press tab to\n  // focus a specific element. Without this fix, the first element in\n  // the `<main>` tag would be focused instead of the closest focusable\n  // element to the click area.\n\n\n  var tabIndex = propTabIndex;\n\n  if (useIsUserInteractionMode(\"keyboard\") && typeof propTabIndex === \"undefined\") {\n    tabIndex = -1;\n  }\n\n  var _f = useLayoutConfig(),\n      layout = _f.layout,\n      visible = _f.visible;\n\n  var navOffset = propNavOffset;\n\n  if (typeof navOffset === \"undefined\") {\n    navOffset = visible && !isTemporaryLayout(layout);\n  }\n\n  var timeout = propTimeout;\n  var prevLayout = useRef(layout);\n\n  if (prevLayout.current !== layout) {\n    // this is kind of weird and hacky, but this will allow for the required\n    // classnames to be applied to the main element based on the current\n    // layout type without needing a unique `key` for the main content. this\n    // is super nice since we really don't want to remount the full app each\n    // time the layout changes.\n    timeout = 0;\n  }\n\n  var _g = useCSSTransition({\n    ref: forwardedRef,\n    transitionIn: !!navOffset,\n    temporary: false,\n    className: propClassName,\n    timeout: timeout,\n    classNames: classNames,\n    onEntered: function () {\n      prevLayout.current = layout;\n    },\n    onExited: function () {\n      prevLayout.current = layout;\n    }\n  }),\n      _h = _g[1],\n      ref = _h.ref,\n      className = _h.className;\n\n  return React.createElement(Component, __assign({}, props, {\n    ref: ref,\n    tabIndex: tabIndex,\n    className: cn(styles({\n      \"header-offset\": headerOffset\n    }), className)\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  try {\n    var PropTypes = require(\"prop-types\");\n\n    LayoutMain.propTypes = {\n      component: PropTypes.oneOf([\"div\", \"main\"]),\n      className: PropTypes.string,\n      tabIndex: PropTypes.number,\n      navOffset: PropTypes.bool,\n      headerOffset: PropTypes.bool,\n      timeout: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n        appear: PropTypes.number,\n        enter: PropTypes.number,\n        exit: PropTypes.number\n      })]),\n      classNames: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n        appear: PropTypes.string,\n        appearActive: PropTypes.string,\n        enter: PropTypes.string,\n        enterActive: PropTypes.string,\n        enterDone: PropTypes.string,\n        exit: PropTypes.string,\n        exitActive: PropTypes.string,\n        exitDone: PropTypes.string\n      })])\n    };\n  } catch (error) {}\n}\n\nexport default LayoutMain;","map":{"version":3,"sources":["../src/LayoutMain.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { forwardRef, useRef } from \"react\";\nimport cn from \"classnames\";\nimport { DEFAULT_SHEET_TIMEOUT } from \"@react-md/sheet\";\nimport { useCSSTransition } from \"@react-md/transition\";\nimport { bem, useIsUserInteractionMode } from \"@react-md/utils\";\nimport { DEFAULT_LAYOUT_MAIN_CLASSNAMES } from \"./constants\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { isTemporaryLayout } from \"./utils\";\nvar styles = bem(\"rmd-layout-main\");\n/**\n * This is the `<main>` element for your app that has some built in styles to be\n * able to update based on the current layout types.\n */\nvar LayoutMain = forwardRef(function LayoutMain(_a, forwardedRef) {\n    var propClassName = _a.className, propTabIndex = _a.tabIndex, _b = _a.component, Component = _b === void 0 ? \"main\" : _b, propNavOffset = _a.navOffset, _c = _a.headerOffset, headerOffset = _c === void 0 ? false : _c, _d = _a.timeout, propTimeout = _d === void 0 ? DEFAULT_SHEET_TIMEOUT : _d, _e = _a.classNames, classNames = _e === void 0 ? DEFAULT_LAYOUT_MAIN_CLASSNAMES : _e, props = __rest(_a, [\"className\", \"tabIndex\", \"component\", \"navOffset\", \"headerOffset\", \"timeout\", \"classNames\"]);\n    // this makes it so that the SkipToMainContent button can still\n    // focus the `<main>` element, but the `<main>` will no longer be\n    // focused if the user clicks inside. This is super nice since one\n    // of my bigger patterns is to click somewhere then press tab to\n    // focus a specific element. Without this fix, the first element in\n    // the `<main>` tag would be focused instead of the closest focusable\n    // element to the click area.\n    var tabIndex = propTabIndex;\n    if (useIsUserInteractionMode(\"keyboard\") &&\n        typeof propTabIndex === \"undefined\") {\n        tabIndex = -1;\n    }\n    var _f = useLayoutConfig(), layout = _f.layout, visible = _f.visible;\n    var navOffset = propNavOffset;\n    if (typeof navOffset === \"undefined\") {\n        navOffset = visible && !isTemporaryLayout(layout);\n    }\n    var timeout = propTimeout;\n    var prevLayout = useRef(layout);\n    if (prevLayout.current !== layout) {\n        // this is kind of weird and hacky, but this will allow for the required\n        // classnames to be applied to the main element based on the current\n        // layout type without needing a unique `key` for the main content. this\n        // is super nice since we really don't want to remount the full app each\n        // time the layout changes.\n        timeout = 0;\n    }\n    var _g = useCSSTransition({\n        ref: forwardedRef,\n        transitionIn: !!navOffset,\n        temporary: false,\n        className: propClassName,\n        timeout: timeout,\n        classNames: classNames,\n        onEntered: function () {\n            prevLayout.current = layout;\n        },\n        onExited: function () {\n            prevLayout.current = layout;\n        },\n    }), _h = _g[1], ref = _h.ref, className = _h.className;\n    return (React.createElement(Component, __assign({}, props, { ref: ref, tabIndex: tabIndex, className: cn(styles({ \"header-offset\": headerOffset }), className) })));\n});\nif (process.env.NODE_ENV !== \"production\") {\n    try {\n        var PropTypes = require(\"prop-types\");\n        LayoutMain.propTypes = {\n            component: PropTypes.oneOf([\"div\", \"main\"]),\n            className: PropTypes.string,\n            tabIndex: PropTypes.number,\n            navOffset: PropTypes.bool,\n            headerOffset: PropTypes.bool,\n            timeout: PropTypes.oneOfType([\n                PropTypes.number,\n                PropTypes.shape({\n                    appear: PropTypes.number,\n                    enter: PropTypes.number,\n                    exit: PropTypes.number,\n                }),\n            ]),\n            classNames: PropTypes.oneOfType([\n                PropTypes.string,\n                PropTypes.shape({\n                    appear: PropTypes.string,\n                    appearActive: PropTypes.string,\n                    enter: PropTypes.string,\n                    enterActive: PropTypes.string,\n                    enterDone: PropTypes.string,\n                    exit: PropTypes.string,\n                    exitActive: PropTypes.string,\n                    exitDone: PropTypes.string,\n                }),\n            ]),\n        };\n    }\n    catch (error) { }\n}\nexport default LayoutMain;\n//# sourceMappingURL=LayoutMain.js.map"]},"metadata":{},"sourceType":"module"}