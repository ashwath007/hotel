{"ast":null,"code":"import { useCallback, useEffect, useRef } from \"react\";\nimport { useToggle, useUserInteractionMode } from \"@react-md/utils\";\nimport { DEFAULT_TOOLTIP_DELAY, DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\nimport { useKeyboardState, useMouseState, useTouchState } from \"./useHandlers\";\nimport usePosition from \"./usePosition\";\nimport useVisiblityChange from \"./useVisibilityChange\";\n/**\n * When the tooltip becomes visible, the tooltip should be hidden if any element\n * within the page is clicked, or the browser is blurred. This hook will just\n * add the required event listeners to hide the tooltip.\n *\n * Whent he entire window is blurred, we start a different flow to ensure that a\n * tooltip won't appear when the window is re-focused. Without this flow, a\n * keyboard user that had focused a tooltippable element will have the tooltip\n * appear again after `x`ms which is not wanted. The user will need to manually\n * re-focus the tooltippable element to show a tooltip again.\n */\n\nexport function useOtherInteractionDisable(initiated, hideTooltip) {\n  useEffect(function () {\n    if (!initiated) {\n      return;\n    }\n\n    window.addEventListener(\"mousedown\", hideTooltip, true);\n    window.addEventListener(\"click\", hideTooltip, true);\n    return function () {\n      window.removeEventListener(\"mousedown\", hideTooltip, true);\n      window.removeEventListener(\"click\", hideTooltip, true);\n    };\n  }, [initiated, hideTooltip]);\n}\n/**\n * This is a reusable hook that allows you to have all the event listeners and\n * visibility logic of toolips so it can be used for any component. This is\n * extremely helpful for when you want to create more complex tooltips (like\n * dialogs).\n *\n * The tooltip state flow is pretty complex, so here's a quick run down of some\n * of the logic:\n * - the tooltip can only be shown by mouse, keyboard, or touch and can only be\n *   closed by the same \"initiation\" type. So basically if the tooltip was shown\n *   via mouse, it can only be closed by mouse as well.\n * - if the user resizes the window, scrolls the page, clicks anywhere on the\n *   page, switches tabs/ blurs the browser window while the tooltip is visible,\n *   the tooltip will be hidden.\n * - a keyboard user can hide the tooltip by pressing the escape key after it\n *   was shown by focusing the element\n *\n * Since the tooltip can appear above or below the element, the position of the\n * tooltip must be determined before the tooltip becomes visible or else the\n * animation will be in the wrong direction.  So when one of the starting\n * interaction types happen to the container element, the initial position is\n * \"guessed\" based on the current viewport height and the position of the\n * container element within the viewport.\n */\n\nexport default function useTooltipState(_a) {\n  var propPosition = _a.position,\n      defaultPosition = _a.defaultPosition,\n      _b = _a.positionThreshold,\n      positionThreshold = _b === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _b,\n      _c = _a.hoverDelay,\n      hoverDelay = _c === void 0 ? DEFAULT_TOOLTIP_DELAY : _c,\n      _d = _a.touchTimeout,\n      touchTimeout = _d === void 0 ? DEFAULT_TOOLTIP_DELAY : _d,\n      _e = _a.focusDelay,\n      focusDelay = _e === void 0 ? DEFAULT_TOOLTIP_DELAY : _e,\n      disableHoverMode = _a.disableHoverMode,\n      onMouseEnter = _a.onMouseEnter,\n      onMouseLeave = _a.onMouseLeave,\n      onTouchStart = _a.onTouchStart,\n      onTouchMove = _a.onTouchMove,\n      onFocus = _a.onFocus,\n      onBlur = _a.onBlur,\n      onKeyDown = _a.onKeyDown,\n      onShow = _a.onShow,\n      onHide = _a.onHide;\n  var mode = useUserInteractionMode();\n  var initiated = useRef(null);\n  var setInitiated = useCallback(function (initiatedBy) {\n    initiated.current = initiatedBy;\n  }, []);\n\n  var _f = useToggle(false),\n      visible = _f[0],\n      showTooltip = _f[1],\n      hide = _f[2];\n\n  var hideTooltip = useCallback(function () {\n    initiated.current = null;\n    hide();\n  }, [hide]);\n  useVisiblityChange({\n    visible: visible,\n    onShow: onShow,\n    onHide: onHide,\n    mode: initiated.current\n  });\n\n  var _g = usePosition({\n    position: propPosition,\n    defaultPosition: defaultPosition,\n    threshold: positionThreshold\n  }),\n      position = _g.position,\n      setEstimatedPosition = _g.setEstimatedPosition;\n\n  var _h = useMouseState({\n    mode: mode,\n    showTooltip: showTooltip,\n    hideTooltip: hideTooltip,\n    delay: hoverDelay,\n    disableHoverMode: disableHoverMode,\n    initiated: initiated,\n    setInitiated: setInitiated,\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    setEstimatedPosition: setEstimatedPosition\n  }),\n      stopMouseTimer = _h[0],\n      handleMouseEnter = _h[1],\n      handleMouseLeave = _h[2];\n\n  var _j = useKeyboardState({\n    mode: mode,\n    showTooltip: showTooltip,\n    hideTooltip: hideTooltip,\n    delay: focusDelay,\n    initiated: initiated,\n    setInitiated: setInitiated,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onKeyDown: onKeyDown,\n    setEstimatedPosition: setEstimatedPosition\n  }),\n      stopKeyboardTimer = _j[0],\n      handleFocus = _j[1],\n      handleBlur = _j[2],\n      handleKeyDown = _j[3];\n\n  var _k = useTouchState({\n    mode: mode,\n    visible: visible,\n    showTooltip: showTooltip,\n    hideTooltip: hideTooltip,\n    delay: touchTimeout,\n    initiated: initiated,\n    setInitiated: setInitiated,\n    onTouchStart: onTouchStart,\n    onTouchMove: onTouchMove,\n    setEstimatedPosition: setEstimatedPosition\n  }),\n      stopTouchTimer = _k[0],\n      handleTouchStart = _k[1],\n      handleTouchMove = _k[2],\n      handleContextMenu = _k[3];\n\n  var hideAndReset = useCallback(function () {\n    stopMouseTimer();\n    stopKeyboardTimer();\n    stopTouchTimer();\n    hide();\n  }, [stopMouseTimer, stopKeyboardTimer, stopTouchTimer, hide]);\n  useOtherInteractionDisable(initiated.current, hideAndReset);\n  return {\n    hide: hide,\n    visible: visible,\n    position: position,\n    handlers: {\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave,\n      onFocus: handleFocus,\n      onBlur: handleBlur,\n      onKeyDown: handleKeyDown,\n      onTouchStart: handleTouchStart,\n      onTouchMove: handleTouchMove,\n      onContextMenu: handleContextMenu\n    }\n  };\n}","map":{"version":3,"sources":["../src/useTooltipState.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useCallback, useEffect, useRef } from \"react\";\nimport { useToggle, useUserInteractionMode, } from \"@react-md/utils\";\nimport { DEFAULT_TOOLTIP_DELAY, DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\nimport { useKeyboardState, useMouseState, useTouchState, } from \"./useHandlers\";\nimport usePosition from \"./usePosition\";\nimport useVisiblityChange from \"./useVisibilityChange\";\n/**\n * When the tooltip becomes visible, the tooltip should be hidden if any element\n * within the page is clicked, or the browser is blurred. This hook will just\n * add the required event listeners to hide the tooltip.\n *\n * Whent he entire window is blurred, we start a different flow to ensure that a\n * tooltip won't appear when the window is re-focused. Without this flow, a\n * keyboard user that had focused a tooltippable element will have the tooltip\n * appear again after `x`ms which is not wanted. The user will need to manually\n * re-focus the tooltippable element to show a tooltip again.\n */\nexport function useOtherInteractionDisable(initiated, hideTooltip) {\n    useEffect(function () {\n        if (!initiated) {\n            return;\n        }\n        window.addEventListener(\"mousedown\", hideTooltip, true);\n        window.addEventListener(\"click\", hideTooltip, true);\n        return function () {\n            window.removeEventListener(\"mousedown\", hideTooltip, true);\n            window.removeEventListener(\"click\", hideTooltip, true);\n        };\n    }, [initiated, hideTooltip]);\n}\n/**\n * This is a reusable hook that allows you to have all the event listeners and\n * visibility logic of toolips so it can be used for any component. This is\n * extremely helpful for when you want to create more complex tooltips (like\n * dialogs).\n *\n * The tooltip state flow is pretty complex, so here's a quick run down of some\n * of the logic:\n * - the tooltip can only be shown by mouse, keyboard, or touch and can only be\n *   closed by the same \"initiation\" type. So basically if the tooltip was shown\n *   via mouse, it can only be closed by mouse as well.\n * - if the user resizes the window, scrolls the page, clicks anywhere on the\n *   page, switches tabs/ blurs the browser window while the tooltip is visible,\n *   the tooltip will be hidden.\n * - a keyboard user can hide the tooltip by pressing the escape key after it\n *   was shown by focusing the element\n *\n * Since the tooltip can appear above or below the element, the position of the\n * tooltip must be determined before the tooltip becomes visible or else the\n * animation will be in the wrong direction.  So when one of the starting\n * interaction types happen to the container element, the initial position is\n * \"guessed\" based on the current viewport height and the position of the\n * container element within the viewport.\n */\nexport default function useTooltipState(_a) {\n    var propPosition = _a.position, defaultPosition = _a.defaultPosition, _b = _a.positionThreshold, positionThreshold = _b === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _b, _c = _a.hoverDelay, hoverDelay = _c === void 0 ? DEFAULT_TOOLTIP_DELAY : _c, _d = _a.touchTimeout, touchTimeout = _d === void 0 ? DEFAULT_TOOLTIP_DELAY : _d, _e = _a.focusDelay, focusDelay = _e === void 0 ? DEFAULT_TOOLTIP_DELAY : _e, disableHoverMode = _a.disableHoverMode, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, onTouchStart = _a.onTouchStart, onTouchMove = _a.onTouchMove, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onShow = _a.onShow, onHide = _a.onHide;\n    var mode = useUserInteractionMode();\n    var initiated = useRef(null);\n    var setInitiated = useCallback(function (initiatedBy) {\n        initiated.current = initiatedBy;\n    }, []);\n    var _f = useToggle(false), visible = _f[0], showTooltip = _f[1], hide = _f[2];\n    var hideTooltip = useCallback(function () {\n        initiated.current = null;\n        hide();\n    }, [hide]);\n    useVisiblityChange({\n        visible: visible,\n        onShow: onShow,\n        onHide: onHide,\n        mode: initiated.current,\n    });\n    var _g = usePosition({\n        position: propPosition,\n        defaultPosition: defaultPosition,\n        threshold: positionThreshold,\n    }), position = _g.position, setEstimatedPosition = _g.setEstimatedPosition;\n    var _h = useMouseState({\n        mode: mode,\n        showTooltip: showTooltip,\n        hideTooltip: hideTooltip,\n        delay: hoverDelay,\n        disableHoverMode: disableHoverMode,\n        initiated: initiated,\n        setInitiated: setInitiated,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        setEstimatedPosition: setEstimatedPosition,\n    }), stopMouseTimer = _h[0], handleMouseEnter = _h[1], handleMouseLeave = _h[2];\n    var _j = useKeyboardState({\n        mode: mode,\n        showTooltip: showTooltip,\n        hideTooltip: hideTooltip,\n        delay: focusDelay,\n        initiated: initiated,\n        setInitiated: setInitiated,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        onKeyDown: onKeyDown,\n        setEstimatedPosition: setEstimatedPosition,\n    }), stopKeyboardTimer = _j[0], handleFocus = _j[1], handleBlur = _j[2], handleKeyDown = _j[3];\n    var _k = useTouchState({\n        mode: mode,\n        visible: visible,\n        showTooltip: showTooltip,\n        hideTooltip: hideTooltip,\n        delay: touchTimeout,\n        initiated: initiated,\n        setInitiated: setInitiated,\n        onTouchStart: onTouchStart,\n        onTouchMove: onTouchMove,\n        setEstimatedPosition: setEstimatedPosition,\n    }), stopTouchTimer = _k[0], handleTouchStart = _k[1], handleTouchMove = _k[2], handleContextMenu = _k[3];\n    var hideAndReset = useCallback(function () {\n        stopMouseTimer();\n        stopKeyboardTimer();\n        stopTouchTimer();\n        hide();\n    }, [stopMouseTimer, stopKeyboardTimer, stopTouchTimer, hide]);\n    useOtherInteractionDisable(initiated.current, hideAndReset);\n    return {\n        hide: hide,\n        visible: visible,\n        position: position,\n        handlers: {\n            onMouseEnter: handleMouseEnter,\n            onMouseLeave: handleMouseLeave,\n            onFocus: handleFocus,\n            onBlur: handleBlur,\n            onKeyDown: handleKeyDown,\n            onTouchStart: handleTouchStart,\n            onTouchMove: handleTouchMove,\n            onContextMenu: handleContextMenu,\n        },\n    };\n}\n//# sourceMappingURL=useTooltipState.js.map"]},"metadata":{},"sourceType":"module"}