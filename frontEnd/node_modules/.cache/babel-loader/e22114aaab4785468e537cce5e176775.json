{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useMemo } from \"react\";\n/**\n * This util performantly builds a nested list of tree items from a giant flat\n * list of items by linking items together with the provided `parentId`. This\n * will also recursively build the tree and _hopefully_ all items will be added.\n *\n * If there are no children for a specific item\n *\n * TODO: Add a dev-only warning/error if the tree is built, but there are some\n * items that never referenced another `itemId`\n *\n * @private\n */\n\nexport function buildTree(parentId, items, sort) {\n  var childItems = []; // doing a \"reverse\" order filter/move so that the items array shrinks while\n  // looping. This makes it so that the entire items array doesn't need to\n  // continually be looped through as more items are added to the tree, only the\n  // remaining items will have to be looped\n\n  var i = items.length;\n\n  while (i > 0) {\n    i -= 1;\n\n    if (items[i] && items[i].parentId === parentId) {\n      var item = items.splice(i, 1)[0]; // shallow cloning so childItems doesn't get applied to the original data\n      // set\n\n      childItems.unshift(__assign({}, item));\n    }\n  }\n\n  if (!childItems.length) {\n    return undefined;\n  }\n\n  childItems.forEach(function (childItem) {\n    childItem.childItems = buildTree(childItem.itemId, items, sort);\n  });\n  return sort ? sort(childItems) : childItems;\n}\n/**\n * This is an internal hook that will create a renderable nested list view of\n * the tree data.\n *\n * @private\n * @param tree The full tree to convert to a nested list representation\n * @param sort An optional function that sorts the items at each level\n * @param rootId The starting `parentId` to use while building the tree.  This\n * defaults to `null` since this is most likely the general use case, but if\n * there's a different unique identifier for the \"root level\" items, that can be\n * used instead.\n */\n\nexport default function useNestedTreeList(tree, sort, rootId) {\n  if (rootId === void 0) {\n    rootId = null;\n  }\n\n  return useMemo(function () {\n    return buildTree(rootId, Object.values(tree), sort) || [];\n  }, [rootId, sort, tree]);\n}","map":{"version":3,"sources":["../src/useNestedTreeList.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,SAAS,OAAT,QAAwB,OAAxB;AAWA;;;;;;;;;;;;;AAYA,OAAM,SAAU,SAAV,CACJ,QADI,EAEJ,KAFI,EAGJ,IAHI,EAGoB;AAExB,MAAM,UAAU,GAAwB,EAAxC,CAFwB,CAIxB;AACA;AACA;AACA;;AACA,MAAI,CAAC,GAAG,KAAK,CAAC,MAAd;;AACA,SAAO,CAAC,GAAG,CAAX,EAAc;AACZ,IAAA,CAAC,IAAI,CAAL;;AACA,QAAI,KAAK,CAAC,CAAD,CAAL,IAAY,KAAK,CAAC,CAAD,CAAL,CAAS,QAAT,KAAsB,QAAtC,EAAgD;AACvC,UAAA,IAAI,GAAI,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,CAAhB,EAAJ,CAAI,CAAR,CADuC,CAE9C;AACA;;AACA,MAAA,UAAU,CAAC,OAAX,CAAkB,QAAA,CAAA,EAAA,EAAM,IAAN,CAAlB;AACD;AACF;;AAED,MAAI,CAAC,UAAU,CAAC,MAAhB,EAAwB;AACtB,WAAO,SAAP;AACD;;AAED,EAAA,UAAU,CAAC,OAAX,CAAmB,UAAC,SAAD,EAAU;AAC3B,IAAA,SAAS,CAAC,UAAV,GAAuB,SAAS,CAAC,SAAS,CAAC,MAAX,EAAmB,KAAnB,EAA0B,IAA1B,CAAhC;AACD,GAFD;AAIA,SAAO,IAAI,GAAG,IAAI,CAAC,UAAD,CAAP,GAAsB,UAAjC;AACD;AAED;;;;;;;;;;;;;AAYA,eAAc,SAAU,iBAAV,CACZ,IADY,EAEZ,IAFY,EAGZ,MAHY,EAGoB;AAAhC,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAA,IAAA;AAAgC;;AAEhC,SAAO,OAAO,CAAC,YAAA;AAAM,WAAA,SAAS,CAAC,MAAD,EAAS,MAAM,CAAC,MAAP,CAAc,IAAd,CAAT,EAA8B,IAA9B,CAAT,IAAA,EAAA;AAAkD,GAAzD,EAA2D,CACvE,MADuE,EAEvE,IAFuE,EAGvE,IAHuE,CAA3D,CAAd;AAKD","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { useMemo } from \"react\";\n/**\n * This util performantly builds a nested list of tree items from a giant flat\n * list of items by linking items together with the provided `parentId`. This\n * will also recursively build the tree and _hopefully_ all items will be added.\n *\n * If there are no children for a specific item\n *\n * TODO: Add a dev-only warning/error if the tree is built, but there are some\n * items that never referenced another `itemId`\n *\n * @private\n */\nexport function buildTree(parentId, items, sort) {\n    var childItems = [];\n    // doing a \"reverse\" order filter/move so that the items array shrinks while\n    // looping. This makes it so that the entire items array doesn't need to\n    // continually be looped through as more items are added to the tree, only the\n    // remaining items will have to be looped\n    var i = items.length;\n    while (i > 0) {\n        i -= 1;\n        if (items[i] && items[i].parentId === parentId) {\n            var item = items.splice(i, 1)[0];\n            // shallow cloning so childItems doesn't get applied to the original data\n            // set\n            childItems.unshift(__assign({}, item));\n        }\n    }\n    if (!childItems.length) {\n        return undefined;\n    }\n    childItems.forEach(function (childItem) {\n        childItem.childItems = buildTree(childItem.itemId, items, sort);\n    });\n    return sort ? sort(childItems) : childItems;\n}\n/**\n * This is an internal hook that will create a renderable nested list view of\n * the tree data.\n *\n * @private\n * @param tree The full tree to convert to a nested list representation\n * @param sort An optional function that sorts the items at each level\n * @param rootId The starting `parentId` to use while building the tree.  This\n * defaults to `null` since this is most likely the general use case, but if\n * there's a different unique identifier for the \"root level\" items, that can be\n * used instead.\n */\nexport default function useNestedTreeList(tree, sort, rootId) {\n    if (rootId === void 0) { rootId = null; }\n    return useMemo(function () { return buildTree(rootId, Object.values(tree), sort) || []; }, [\n        rootId,\n        sort,\n        tree,\n    ]);\n}\n//# sourceMappingURL=useNestedTreeList.js.map"]},"metadata":{},"sourceType":"module"}