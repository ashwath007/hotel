{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useTimeout, useToggle } from \"@react-md/utils\";\nimport { DEFAULT_MESSAGE_QUEUE_TIMEOUT } from \"./MessageQueueContext\";\nimport useWindowBlurPause from \"./useWindowBlurPause\";\nexport var ADD_MESSAGE = \"ADD_MESSAGE\";\nexport var POP_MESSAGE = \"POP_MESSAGE\";\nexport var RESET_QUEUE = \"RESET_QUEUE\";\n/**\n * @private\n */\n\nexport function addMessage(message, duplicates) {\n  return {\n    type: ADD_MESSAGE,\n    message: message,\n    duplicates: duplicates\n  };\n}\n/**\n * @private\n */\n\nexport var popMessage = function () {\n  return {\n    type: POP_MESSAGE\n  };\n};\n/**\n * @private\n */\n\nexport var resetQueue = function () {\n  return {\n    type: RESET_QUEUE\n  };\n};\n/**\n * This function is used to update the message queue state by adding a new message when\n * needed.\n *\n * @private\n */\n\nexport function handleAddMessage(state, message, duplicates) {\n  if (state.length === 0) {\n    return [message];\n  }\n\n  var messageId = message.messageId,\n      _a = message.messagePriority,\n      messagePriority = _a === void 0 ? \"normal\" : _a;\n  var i = state.findIndex(function (mes) {\n    return mes.messageId === messageId;\n  });\n  var isNext = messagePriority === \"next\";\n  var isNormal = messagePriority === \"normal\";\n  var isReplace = messagePriority === \"replace\";\n  var isImmediate = messagePriority === \"immediate\";\n  var isDuplicable = duplicates === \"allow\";\n  var isRestart = duplicates === \"restart\";\n\n  if (isNext || isImmediate) {\n    var nextState = state.slice(); // remove the existing message if duplicated messages aren't allowed. This will\n    // kind of act like a replace + next behavior\n\n    if (!isDuplicable && i > 0) {\n      nextState.splice(i, 1);\n    }\n\n    var current = nextState[0],\n        remaining = nextState.slice(1);\n\n    if (isImmediate && current.messagePriority !== \"immediate\") {\n      return __spreadArrays([current, message, current], remaining);\n    }\n\n    return __spreadArrays([current, message], remaining);\n  }\n\n  if (i === -1 || isDuplicable && isNormal) {\n    return __spreadArrays(state, [message]);\n  }\n\n  if (isNormal) {\n    if (isRestart) {\n      // creating a new state so that the queue visibility hook can still be triggered\n      // which will restart the timer\n      return state.slice();\n    }\n\n    return state;\n  }\n\n  if (isReplace) {\n    var nextState = state.slice();\n    nextState[i] = message;\n    return nextState;\n  }\n\n  return __spreadArrays(state, [message]);\n}\n/**\n * @private\n */\n\nexport function reducer(state, action) {\n  switch (action.type) {\n    case ADD_MESSAGE:\n      return handleAddMessage(state, action.message, action.duplicates);\n\n    case POP_MESSAGE:\n      return state.length ? state.slice(1) : state;\n\n    case RESET_QUEUE:\n      return state.length ? [] : state;\n\n    default:\n      return state;\n  }\n}\n/**\n * This is the main logic for the message queue behavior that will handle:\n *\n * - creating timeouts as needed to show/hide toasts within the SnackbarQueue component\n * - create a way to push messages with optional priority onto the queue\n *\n * @private\n */\n\nexport default function useMessageQueue(_a) {\n  var _b = _a.timeout,\n      timeout = _b === void 0 ? DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b,\n      _c = _a.duplicates,\n      duplicates = _c === void 0 ? \"allow\" : _c,\n      _d = _a.defaultQueue,\n      defaultQueue = _d === void 0 ? [] : _d;\n\n  var _e = useReducer(function (state, action) {\n    return reducer(state, action);\n  }, defaultQueue),\n      queue = _e[0],\n      dispatch = _e[1];\n\n  var queueRef = useRef(queue);\n  var addMessageDispatch = useCallback(function (message) {\n    if (duplicates !== \"allow\" && !message.messageId) {\n      throw new Error(\"A messageId is required when the \\\"\" + duplicates + \"\\\" duplicate behavior is enabled but it was not provided in the current message.\");\n    }\n\n    dispatch({\n      type: ADD_MESSAGE,\n      message: message,\n      duplicates: duplicates\n    });\n  }, [duplicates]);\n  var popMessageDispatch = useCallback(function () {\n    dispatch(popMessage());\n  }, []);\n  var resetQueueDispatch = useCallback(function () {\n    dispatch(resetQueue());\n    return queueRef.current;\n  }, []);\n\n  var _f = useToggle(defaultQueue.length > 0),\n      visible = _f[0],\n      showMessage = _f[1],\n      hideMessage = _f[2];\n\n  var _g = useTimeout(hideMessage, timeout),\n      startTimer = _g[0],\n      stopTimer = _g[1],\n      restartTimer = _g[2];\n\n  useEffect(function () {\n    // this effect will handle all the \"logic\" for transitioning between each message along with the\n    // message priority updates.\n    var message = queue[0],\n        nextMessage = queue[1];\n\n    if (!message) {\n      return;\n    }\n\n    var prevQueue = queueRef.current;\n    var prevMessage = prevQueue[0];\n\n    if (message.messagePriority !== \"immediate\" && nextMessage && nextMessage.messagePriority === \"immediate\") {\n      stopTimer();\n\n      if (!visible) {\n        popMessageDispatch();\n        return;\n      }\n\n      hideMessage();\n      return;\n    }\n\n    if (!visible) {\n      showMessage();\n    }\n\n    if (queue.length === prevQueue.length && message === prevMessage) {\n      restartTimer();\n    } // only want to run this on queue changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [queue]);\n  useWindowBlurPause({\n    startTimer: startTimer,\n    stopTimer: stopTimer,\n    visible: visible,\n    message: queue[0]\n  });\n  useEffect(function () {\n    queueRef.current = queue;\n  });\n  return {\n    queue: queue,\n    resetQueue: resetQueueDispatch,\n    visible: visible,\n    hideMessage: hideMessage,\n    addMessage: addMessageDispatch,\n    popMessage: popMessageDispatch,\n    startTimer: startTimer,\n    stopTimer: stopTimer,\n    restartTimer: restartTimer\n  };\n}","map":{"version":3,"sources":["../src/useMessageQueue.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useTimeout, useToggle } from \"@react-md/utils\";\nimport { DEFAULT_MESSAGE_QUEUE_TIMEOUT, } from \"./MessageQueueContext\";\nimport useWindowBlurPause from \"./useWindowBlurPause\";\nexport var ADD_MESSAGE = \"ADD_MESSAGE\";\nexport var POP_MESSAGE = \"POP_MESSAGE\";\nexport var RESET_QUEUE = \"RESET_QUEUE\";\n/**\n * @private\n */\nexport function addMessage(message, duplicates) {\n    return { type: ADD_MESSAGE, message: message, duplicates: duplicates };\n}\n/**\n * @private\n */\nexport var popMessage = function () { return ({ type: POP_MESSAGE }); };\n/**\n * @private\n */\nexport var resetQueue = function () { return ({ type: RESET_QUEUE }); };\n/**\n * This function is used to update the message queue state by adding a new message when\n * needed.\n *\n * @private\n */\nexport function handleAddMessage(state, message, duplicates) {\n    if (state.length === 0) {\n        return [message];\n    }\n    var messageId = message.messageId, _a = message.messagePriority, messagePriority = _a === void 0 ? \"normal\" : _a;\n    var i = state.findIndex(function (mes) { return mes.messageId === messageId; });\n    var isNext = messagePriority === \"next\";\n    var isNormal = messagePriority === \"normal\";\n    var isReplace = messagePriority === \"replace\";\n    var isImmediate = messagePriority === \"immediate\";\n    var isDuplicable = duplicates === \"allow\";\n    var isRestart = duplicates === \"restart\";\n    if (isNext || isImmediate) {\n        var nextState = state.slice();\n        // remove the existing message if duplicated messages aren't allowed. This will\n        // kind of act like a replace + next behavior\n        if (!isDuplicable && i > 0) {\n            nextState.splice(i, 1);\n        }\n        var current = nextState[0], remaining = nextState.slice(1);\n        if (isImmediate && current.messagePriority !== \"immediate\") {\n            return __spreadArrays([current, message, current], remaining);\n        }\n        return __spreadArrays([current, message], remaining);\n    }\n    if (i === -1 || (isDuplicable && isNormal)) {\n        return __spreadArrays(state, [message]);\n    }\n    if (isNormal) {\n        if (isRestart) {\n            // creating a new state so that the queue visibility hook can still be triggered\n            // which will restart the timer\n            return state.slice();\n        }\n        return state;\n    }\n    if (isReplace) {\n        var nextState = state.slice();\n        nextState[i] = message;\n        return nextState;\n    }\n    return __spreadArrays(state, [message]);\n}\n/**\n * @private\n */\nexport function reducer(state, action) {\n    switch (action.type) {\n        case ADD_MESSAGE:\n            return handleAddMessage(state, action.message, action.duplicates);\n        case POP_MESSAGE:\n            return state.length ? state.slice(1) : state;\n        case RESET_QUEUE:\n            return state.length ? [] : state;\n        default:\n            return state;\n    }\n}\n/**\n * This is the main logic for the message queue behavior that will handle:\n *\n * - creating timeouts as needed to show/hide toasts within the SnackbarQueue component\n * - create a way to push messages with optional priority onto the queue\n *\n * @private\n */\nexport default function useMessageQueue(_a) {\n    var _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b, _c = _a.duplicates, duplicates = _c === void 0 ? \"allow\" : _c, _d = _a.defaultQueue, defaultQueue = _d === void 0 ? [] : _d;\n    var _e = useReducer(function (state, action) { return reducer(state, action); }, defaultQueue), queue = _e[0], dispatch = _e[1];\n    var queueRef = useRef(queue);\n    var addMessageDispatch = useCallback(function (message) {\n        if (duplicates !== \"allow\" && !message.messageId) {\n            throw new Error(\"A messageId is required when the \\\"\" + duplicates + \"\\\" duplicate behavior is enabled but it was not provided in the current message.\");\n        }\n        dispatch({ type: ADD_MESSAGE, message: message, duplicates: duplicates });\n    }, [duplicates]);\n    var popMessageDispatch = useCallback(function () {\n        dispatch(popMessage());\n    }, []);\n    var resetQueueDispatch = useCallback(function () {\n        dispatch(resetQueue());\n        return queueRef.current;\n    }, []);\n    var _f = useToggle(defaultQueue.length > 0), visible = _f[0], showMessage = _f[1], hideMessage = _f[2];\n    var _g = useTimeout(hideMessage, timeout), startTimer = _g[0], stopTimer = _g[1], restartTimer = _g[2];\n    useEffect(function () {\n        // this effect will handle all the \"logic\" for transitioning between each message along with the\n        // message priority updates.\n        var message = queue[0], nextMessage = queue[1];\n        if (!message) {\n            return;\n        }\n        var prevQueue = queueRef.current;\n        var prevMessage = prevQueue[0];\n        if (message.messagePriority !== \"immediate\" &&\n            nextMessage &&\n            nextMessage.messagePriority === \"immediate\") {\n            stopTimer();\n            if (!visible) {\n                popMessageDispatch();\n                return;\n            }\n            hideMessage();\n            return;\n        }\n        if (!visible) {\n            showMessage();\n        }\n        if (queue.length === prevQueue.length && message === prevMessage) {\n            restartTimer();\n        }\n        // only want to run this on queue changes\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [queue]);\n    useWindowBlurPause({\n        startTimer: startTimer,\n        stopTimer: stopTimer,\n        visible: visible,\n        message: queue[0],\n    });\n    useEffect(function () {\n        queueRef.current = queue;\n    });\n    return {\n        queue: queue,\n        resetQueue: resetQueueDispatch,\n        visible: visible,\n        hideMessage: hideMessage,\n        addMessage: addMessageDispatch,\n        popMessage: popMessageDispatch,\n        startTimer: startTimer,\n        stopTimer: stopTimer,\n        restartTimer: restartTimer,\n    };\n}\n//# sourceMappingURL=useMessageQueue.js.map"]},"metadata":{},"sourceType":"module"}