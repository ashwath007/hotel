{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useCallback, useEffect, useMemo, useRef, useState, createContext, useContext } from \"react\";\nimport { useResizeObserver } from \"@react-md/utils\";\nvar TAB_WIDTH_VAR = \"--rmd-tab-width\";\nvar TAB_OFFSET_VAR = \"--rmd-tab-offset\";\n\nvar getActiveTab = function (itemRefs, activeIndex) {\n  return itemRefs[activeIndex] && itemRefs[activeIndex].current || null;\n};\n/**\n * @since 2.3.0\n * @private\n * @internal\n */\n\n\nvar context = createContext(function () {});\n/**\n * @since 2.3.0\n * @private\n * @internal\n */\n\nexport var UpdateIndicatorStylesProvider = context.Provider;\n/**\n * @since 2.3.0\n * @private\n * @internal\n */\n\nexport function useUpdateIndicatorStyles() {\n  return useContext(context);\n}\n/**\n * This hook will merge the provided style object along with the required css\n * variables for the active tab underline moving to the correct location. The\n * indicator will be updated to be the same width as the tab along with offset\n * by all the tabs' sizes.\n *\n * @private\n */\n\nexport default function useTabIndicatorStyle(_a) {\n  var style = _a.style,\n      propRef = _a.ref,\n      align = _a.align,\n      itemRefs = _a.itemRefs,\n      totalTabs = _a.totalTabs,\n      activeIndex = _a.activeIndex;\n\n  var _b = useState(function () {\n    var _a;\n\n    var tabWidth = 100 / totalTabs + \"%\";\n    return _a = {}, _a[TAB_WIDTH_VAR] = tabWidth, _a[TAB_OFFSET_VAR] = \"calc(\" + activeIndex + \" * \" + tabWidth + \")\", _a;\n  }),\n      cssVars = _b[0],\n      setCSSVars = _b[1];\n\n  var prevCSSVars = useRef(cssVars);\n  var updateCSSVars = useCallback(function (itemRefs, activeIndex) {\n    var _a;\n\n    var activeTab = getActiveTab(itemRefs, activeIndex);\n\n    if (!activeTab) {\n      return;\n    }\n\n    var nextCSSVars = (_a = {}, _a[TAB_WIDTH_VAR] = activeTab.offsetWidth + \"px\", _a[TAB_OFFSET_VAR] = activeTab.offsetLeft + \"px\", _a);\n    var cssVars = prevCSSVars.current;\n\n    if (cssVars[TAB_WIDTH_VAR] !== nextCSSVars[TAB_WIDTH_VAR] || cssVars[TAB_OFFSET_VAR] !== nextCSSVars[TAB_OFFSET_VAR]) {\n      prevCSSVars.current = nextCSSVars;\n      setCSSVars(nextCSSVars);\n    }\n  }, []);\n  useEffect(function () {\n    updateCSSVars(itemRefs, activeIndex); // has to also be triggered for align changes since the indicator offset\n    // will be incorrect for that.\n  }, [activeIndex, itemRefs, updateCSSVars, align]);\n  var updateStyles = useCallback(function () {\n    updateCSSVars(itemRefs, activeIndex);\n  }, [itemRefs, activeIndex, updateCSSVars]); // whenever the tabs container element is resized, it _probably_ means\n  // that the tabs will be resized or moved. this means the indicator will\n  // be in the wrong place so we need to fix it here.\n\n  var _c = useResizeObserver(updateStyles, {\n    ref: propRef\n  }),\n      tabsRef = _c[0],\n      tabsRefHandler = _c[1];\n\n  var mergedStyle = useMemo(function () {\n    return __assign(__assign({}, style), cssVars);\n  }, [style, cssVars]);\n  return [mergedStyle, tabsRefHandler, tabsRef, updateStyles];\n}","map":{"version":3,"sources":["../src/useTabIndicatorStyle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { useCallback, useEffect, useMemo, useRef, useState, createContext, useContext, } from \"react\";\nimport { useResizeObserver } from \"@react-md/utils\";\nvar TAB_WIDTH_VAR = \"--rmd-tab-width\";\nvar TAB_OFFSET_VAR = \"--rmd-tab-offset\";\nvar getActiveTab = function (itemRefs, activeIndex) {\n    return (itemRefs[activeIndex] && itemRefs[activeIndex].current) || null;\n};\n/**\n * @since 2.3.0\n * @private\n * @internal\n */\nvar context = createContext(function () { });\n/**\n * @since 2.3.0\n * @private\n * @internal\n */\nexport var UpdateIndicatorStylesProvider = context.Provider;\n/**\n * @since 2.3.0\n * @private\n * @internal\n */\nexport function useUpdateIndicatorStyles() {\n    return useContext(context);\n}\n/**\n * This hook will merge the provided style object along with the required css\n * variables for the active tab underline moving to the correct location. The\n * indicator will be updated to be the same width as the tab along with offset\n * by all the tabs' sizes.\n *\n * @private\n */\nexport default function useTabIndicatorStyle(_a) {\n    var style = _a.style, propRef = _a.ref, align = _a.align, itemRefs = _a.itemRefs, totalTabs = _a.totalTabs, activeIndex = _a.activeIndex;\n    var _b = useState(function () {\n        var _a;\n        var tabWidth = 100 / totalTabs + \"%\";\n        return _a = {},\n            _a[TAB_WIDTH_VAR] = tabWidth,\n            _a[TAB_OFFSET_VAR] = \"calc(\" + activeIndex + \" * \" + tabWidth + \")\",\n            _a;\n    }), cssVars = _b[0], setCSSVars = _b[1];\n    var prevCSSVars = useRef(cssVars);\n    var updateCSSVars = useCallback(function (itemRefs, activeIndex) {\n        var _a;\n        var activeTab = getActiveTab(itemRefs, activeIndex);\n        if (!activeTab) {\n            return;\n        }\n        var nextCSSVars = (_a = {},\n            _a[TAB_WIDTH_VAR] = activeTab.offsetWidth + \"px\",\n            _a[TAB_OFFSET_VAR] = activeTab.offsetLeft + \"px\",\n            _a);\n        var cssVars = prevCSSVars.current;\n        if (cssVars[TAB_WIDTH_VAR] !== nextCSSVars[TAB_WIDTH_VAR] ||\n            cssVars[TAB_OFFSET_VAR] !== nextCSSVars[TAB_OFFSET_VAR]) {\n            prevCSSVars.current = nextCSSVars;\n            setCSSVars(nextCSSVars);\n        }\n    }, []);\n    useEffect(function () {\n        updateCSSVars(itemRefs, activeIndex);\n        // has to also be triggered for align changes since the indicator offset\n        // will be incorrect for that.\n    }, [activeIndex, itemRefs, updateCSSVars, align]);\n    var updateStyles = useCallback(function () {\n        updateCSSVars(itemRefs, activeIndex);\n    }, [itemRefs, activeIndex, updateCSSVars]);\n    // whenever the tabs container element is resized, it _probably_ means\n    // that the tabs will be resized or moved. this means the indicator will\n    // be in the wrong place so we need to fix it here.\n    var _c = useResizeObserver(updateStyles, {\n        ref: propRef,\n    }), tabsRef = _c[0], tabsRefHandler = _c[1];\n    var mergedStyle = useMemo(function () { return (__assign(__assign({}, style), cssVars)); }, [\n        style,\n        cssVars,\n    ]);\n    return [mergedStyle, tabsRefHandler, tabsRef, updateStyles];\n}\n//# sourceMappingURL=useTabIndicatorStyle.js.map"]},"metadata":{},"sourceType":"module"}