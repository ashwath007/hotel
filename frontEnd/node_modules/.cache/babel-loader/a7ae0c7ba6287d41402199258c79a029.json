{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useState, useMemo, useEffect } from \"react\";\nimport { useKeyboardMovement, MovementPresets, getFocusableElements, extractTextContent } from \"@react-md/utils\";\n/**\n * This hook allows for the keyboard movement within a menu. It'll make sure\n * that the arrow keys and typing letters can correctly focus menu items. In\n * addition, it'll automatically swap to the left and right arrow keys if the\n * menu is displayed horizontally.\n */\n\nexport default function useMenuKeyDown(_a) {\n  var menu = _a.menu,\n      onKeyDown = _a.onKeyDown,\n      onRequestClose = _a.onRequestClose,\n      portalled = _a.portalled,\n      horizontal = _a.horizontal,\n      defaultFocus = _a.defaultFocus;\n\n  var _b = useState(0),\n      focusedIndex = _b[0],\n      setFocusedIndex = _b[1];\n\n  var items = useMemo(function () {\n    if (!menu) {\n      return [];\n    }\n\n    return getFocusableElements(menu, true);\n  }, [menu]);\n  useEffect(function () {\n    if (!menu) {\n      return;\n    }\n\n    if (defaultFocus === \"last\") {\n      setFocusedIndex(items.length - 1);\n    } else {\n      setFocusedIndex(0);\n    } // only want to trigger this on initial menu mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [menu]);\n  return useKeyboardMovement(__assign(__assign({}, horizontal ? MovementPresets.HORIZONTAL_MENU : MovementPresets.VERTICAL_MENU), {\n    focusedIndex: focusedIndex,\n    onChange: function (_a) {\n      var index = _a.index;\n      setFocusedIndex(index);\n\n      if (items[index]) {\n        items[index].focus();\n      }\n    },\n    items: items.map(function (item) {\n      return extractTextContent(item);\n    }),\n    onKeyDown: function (event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      if (event.key === \"Escape\") {\n        event.stopPropagation();\n        onRequestClose();\n      } else if (event.key === \"Tab\") {\n        if (portalled) {\n          // have to prevent default tab behavior since tab order is ruined when\n          // something is portalled. this will make it interact the same as if\n          // it was an escape keypress. it's too much work to try to emulate a\n          // real tab here\n          event.preventDefault();\n        }\n\n        onRequestClose();\n      }\n    }\n  }))[1];\n}","map":{"version":3,"sources":["../src/useMenuKeyDown.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,SAAS,QAAT,EAAmB,OAAnB,EAA4B,SAA5B,QAA6C,OAA7C;AACA,SACE,mBADF,EAEE,eAFF,EAGE,oBAHF,EAIE,kBAJF,QAKO,iBALP;AAgBA;;;;;;;AAMA,eAAc,SAAU,cAAV,CAAyB,EAAzB,EAOO;MANnB,IAAI,GAAA,EAAA,CAAA,I;MACJ,SAAS,GAAA,EAAA,CAAA,S;MACT,cAAc,GAAA,EAAA,CAAA,c;MACd,SAAS,GAAA,EAAA,CAAA,S;MACT,UAAU,GAAA,EAAA,CAAA,U;MACV,YAAY,GAAA,EAAA,CAAA,Y;;AAEN,MAAA,EAAA,GAAkC,QAAQ,CAAC,CAAD,CAA1C;AAAA,MAAC,YAAY,GAAA,EAAA,CAAA,CAAA,CAAb;AAAA,MAAe,eAAe,GAAA,EAAA,CAAA,CAAA,CAA9B;;AACN,MAAM,KAAK,GAAG,OAAO,CAAC,YAAA;AACpB,QAAI,CAAC,IAAL,EAAW;AACT,aAAO,EAAP;AACD;;AAED,WAAO,oBAAoB,CAAC,IAAD,EAAO,IAAP,CAA3B;AACD,GANoB,EAMlB,CAAC,IAAD,CANkB,CAArB;AAQA,EAAA,SAAS,CAAC,YAAA;AACR,QAAI,CAAC,IAAL,EAAW;AACT;AACD;;AAED,QAAI,YAAY,KAAK,MAArB,EAA6B;AAC3B,MAAA,eAAe,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAf;AACD,KAFD,MAEO;AACL,MAAA,eAAe,CAAC,CAAD,CAAf;AACD,KATO,CAWR;AACA;;AACD,GAbQ,EAaN,CAAC,IAAD,CAbM,CAAT;AAeA,SAAO,mBAAmB,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACpB,UAAU,GACV,eAAe,CAAC,eADN,GAEV,eAAe,CAAC,aAHI,CAAA,EAGU;AAClC,IAAA,YAAY,EAAA,YADsB;AAElC,IAAA,QAAQ,EAAA,UAAC,EAAD,EAAU;UAAP,KAAK,GAAA,EAAA,CAAA,K;AACd,MAAA,eAAe,CAAC,KAAD,CAAf;;AACA,UAAI,KAAK,CAAC,KAAD,CAAT,EAAkB;AAChB,QAAA,KAAK,CAAC,KAAD,CAAL,CAAa,KAAb;AACD;AACF,KAPiC;AAQlC,IAAA,KAAK,EAAE,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD,EAAK;AAAK,aAAA,kBAAkB,CAAlB,IAAkB,CAAlB;AAAwB,KAA5C,CAR2B;AASlC,IAAA,SAAS,EAAA,UAAC,KAAD,EAAM;AACb,UAAI,SAAJ,EAAe;AACb,QAAA,SAAS,CAAC,KAAD,CAAT;AACD;;AAED,UAAI,KAAK,CAAC,GAAN,KAAc,QAAlB,EAA4B;AAC1B,QAAA,KAAK,CAAC,eAAN;AACA,QAAA,cAAc;AACf,OAHD,MAGO,IAAI,KAAK,CAAC,GAAN,KAAc,KAAlB,EAAyB;AAC9B,YAAI,SAAJ,EAAe;AACb;AACA;AACA;AACA;AACA,UAAA,KAAK,CAAC,cAAN;AACD;;AAED,QAAA,cAAc;AACf;AACF;AA5BiC,GAHV,CAAA,CAAnB,CAgCJ,CAhCI,CAAP;AAiCD","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { useState, useMemo, useEffect } from \"react\";\nimport { useKeyboardMovement, MovementPresets, getFocusableElements, extractTextContent, } from \"@react-md/utils\";\n/**\n * This hook allows for the keyboard movement within a menu. It'll make sure\n * that the arrow keys and typing letters can correctly focus menu items. In\n * addition, it'll automatically swap to the left and right arrow keys if the\n * menu is displayed horizontally.\n */\nexport default function useMenuKeyDown(_a) {\n    var menu = _a.menu, onKeyDown = _a.onKeyDown, onRequestClose = _a.onRequestClose, portalled = _a.portalled, horizontal = _a.horizontal, defaultFocus = _a.defaultFocus;\n    var _b = useState(0), focusedIndex = _b[0], setFocusedIndex = _b[1];\n    var items = useMemo(function () {\n        if (!menu) {\n            return [];\n        }\n        return getFocusableElements(menu, true);\n    }, [menu]);\n    useEffect(function () {\n        if (!menu) {\n            return;\n        }\n        if (defaultFocus === \"last\") {\n            setFocusedIndex(items.length - 1);\n        }\n        else {\n            setFocusedIndex(0);\n        }\n        // only want to trigger this on initial menu mount\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [menu]);\n    return useKeyboardMovement(__assign(__assign({}, (horizontal\n        ? MovementPresets.HORIZONTAL_MENU\n        : MovementPresets.VERTICAL_MENU)), { focusedIndex: focusedIndex,\n        onChange: function (_a) {\n            var index = _a.index;\n            setFocusedIndex(index);\n            if (items[index]) {\n                items[index].focus();\n            }\n        }, items: items.map(function (item) { return extractTextContent(item); }), onKeyDown: function (event) {\n            if (onKeyDown) {\n                onKeyDown(event);\n            }\n            if (event.key === \"Escape\") {\n                event.stopPropagation();\n                onRequestClose();\n            }\n            else if (event.key === \"Tab\") {\n                if (portalled) {\n                    // have to prevent default tab behavior since tab order is ruined when\n                    // something is portalled. this will make it interact the same as if\n                    // it was an escape keypress. it's too much work to try to emulate a\n                    // real tab here\n                    event.preventDefault();\n                }\n                onRequestClose();\n            }\n        } }))[1];\n}\n//# sourceMappingURL=useMenuKeyDown.js.map"]},"metadata":{},"sourceType":"module"}