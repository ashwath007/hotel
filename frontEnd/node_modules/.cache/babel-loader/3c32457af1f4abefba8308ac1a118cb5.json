{"ast":null,"code":"import { useState, useRef, useCallback, useEffect } from \"react\";\nimport useRefCache from \"../useRefCache\";\nexport var DEFAULT_TOUCH_TIMEOUT = 1200;\n/**\n * This is a small hook that is used to determine if the app is currently being\n * used by a touch device or not. All this really does is switch between\n * mousemove and touchstart events to determine which mode you are in.  This\n * also tracks the `contextmenu` appearance since long touches can trigger the\n * context menu on mobile devices. When the context menu appears after a touch,\n * the mode will still be considered \"touch\" instead of swapping to mouse.\n *\n * @param touchTimeout This is the amount of time that can occur between a\n * touchstart and mousemove event but still be considered part of a \"touch\" user\n * mode. This should probably be kept at the default value, but if the touch\n * mode isn't updating as you would expect, you can try increasing or decreasing\n * this value until it does.\n * @return true if the app is in touch mode.\n * @private\n */\n\nexport default function useTouchDetection(touchTimeout) {\n  if (touchTimeout === void 0) {\n    touchTimeout = DEFAULT_TOUCH_TIMEOUT;\n  }\n\n  var _a = useState(0),\n      lastTouchTime = _a[0],\n      setTouchTime = _a[1];\n\n  var touchRef = useRefCache(lastTouchTime);\n  var contextMenuRef = useRef(false);\n  var updateTouchTime = useCallback(function () {\n    setTouchTime(Date.now());\n    contextMenuRef.current = false;\n  }, []);\n  var resetTouchTime = useCallback(function () {\n    var lastTouchTime = touchRef.current;\n\n    if (contextMenuRef.current || Date.now() - lastTouchTime < touchTimeout) {\n      contextMenuRef.current = false;\n      return;\n    }\n\n    setTouchTime(0); // disabled since useRefCache for touchRef\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [touchTimeout]);\n  useEffect(function () {\n    window.addEventListener(\"touchstart\", updateTouchTime, true);\n    return function () {\n      window.removeEventListener(\"touchstart\", updateTouchTime, true);\n    };\n  }, [updateTouchTime]);\n  useEffect(function () {\n    if (lastTouchTime === 0) {\n      contextMenuRef.current = false;\n      return;\n    }\n\n    var updateContextMenu = function () {\n      contextMenuRef.current = true;\n    };\n\n    window.addEventListener(\"mousemove\", resetTouchTime, true);\n    window.addEventListener(\"contextmenu\", updateContextMenu, true);\n    return function () {\n      window.removeEventListener(\"mousemove\", resetTouchTime, true);\n      window.removeEventListener(\"contextmenu\", updateContextMenu, true);\n    };\n  }, [lastTouchTime, resetTouchTime]);\n  return lastTouchTime !== 0;\n}","map":{"version":3,"sources":["../../src/interaction/useTouchDetection.ts"],"names":[],"mappings":"AAAA,SAAS,QAAT,EAAmB,MAAnB,EAA2B,WAA3B,EAAwC,SAAxC,QAAyD,OAAzD;AACA,OAAO,WAAP,MAAwB,gBAAxB;AAEA,OAAO,IAAM,qBAAqB,GAAG,IAA9B;AAEP;;;;;;;;;;;;;;;;;AAgBA,eAAc,SAAU,iBAAV,CACZ,YADY,EACgC;AAA5C,MAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,YAAA,GAAA,qBAAA;AAA4C;;AAEtC,MAAA,EAAA,GAAgC,QAAQ,CAAC,CAAD,CAAxC;AAAA,MAAC,aAAa,GAAA,EAAA,CAAA,CAAA,CAAd;AAAA,MAAgB,YAAY,GAAA,EAAA,CAAA,CAAA,CAA5B;;AACN,MAAM,QAAQ,GAAG,WAAW,CAAC,aAAD,CAA5B;AACA,MAAM,cAAc,GAAG,MAAM,CAAC,KAAD,CAA7B;AAEA,MAAM,eAAe,GAAG,WAAW,CAAC,YAAA;AAClC,IAAA,YAAY,CAAC,IAAI,CAAC,GAAL,EAAD,CAAZ;AACA,IAAA,cAAc,CAAC,OAAf,GAAyB,KAAzB;AACD,GAHkC,EAGhC,EAHgC,CAAnC;AAKA,MAAM,cAAc,GAAG,WAAW,CAAC,YAAA;AACjC,QAAM,aAAa,GAAG,QAAQ,CAAC,OAA/B;;AACA,QAAI,cAAc,CAAC,OAAf,IAA0B,IAAI,CAAC,GAAL,KAAa,aAAb,GAA6B,YAA3D,EAAyE;AACvE,MAAA,cAAc,CAAC,OAAf,GAAyB,KAAzB;AACA;AACD;;AAED,IAAA,YAAY,CAAC,CAAD,CAAZ,CAPiC,CAQjC;AACA;AACD,GAViC,EAU/B,CAAC,YAAD,CAV+B,CAAlC;AAYA,EAAA,SAAS,CAAC,YAAA;AACR,IAAA,MAAM,CAAC,gBAAP,CAAwB,YAAxB,EAAsC,eAAtC,EAAuD,IAAvD;AAEA,WAAO,YAAA;AACL,MAAA,MAAM,CAAC,mBAAP,CAA2B,YAA3B,EAAyC,eAAzC,EAA0D,IAA1D;AACD,KAFD;AAGD,GANQ,EAMN,CAAC,eAAD,CANM,CAAT;AAQA,EAAA,SAAS,CAAC,YAAA;AACR,QAAI,aAAa,KAAK,CAAtB,EAAyB;AACvB,MAAA,cAAc,CAAC,OAAf,GAAyB,KAAzB;AACA;AACD;;AAED,QAAM,iBAAiB,GAAG,YAAA;AACxB,MAAA,cAAc,CAAC,OAAf,GAAyB,IAAzB;AACD,KAFD;;AAIA,IAAA,MAAM,CAAC,gBAAP,CAAwB,WAAxB,EAAqC,cAArC,EAAqD,IAArD;AACA,IAAA,MAAM,CAAC,gBAAP,CAAwB,aAAxB,EAAuC,iBAAvC,EAA0D,IAA1D;AACA,WAAO,YAAA;AACL,MAAA,MAAM,CAAC,mBAAP,CAA2B,WAA3B,EAAwC,cAAxC,EAAwD,IAAxD;AACA,MAAA,MAAM,CAAC,mBAAP,CAA2B,aAA3B,EAA0C,iBAA1C,EAA6D,IAA7D;AACD,KAHD;AAID,GAhBQ,EAgBN,CAAC,aAAD,EAAgB,cAAhB,CAhBM,CAAT;AAkBA,SAAO,aAAa,KAAK,CAAzB;AACD","sourceRoot":"","sourcesContent":["import { useState, useRef, useCallback, useEffect } from \"react\";\nimport useRefCache from \"../useRefCache\";\nexport var DEFAULT_TOUCH_TIMEOUT = 1200;\n/**\n * This is a small hook that is used to determine if the app is currently being\n * used by a touch device or not. All this really does is switch between\n * mousemove and touchstart events to determine which mode you are in.  This\n * also tracks the `contextmenu` appearance since long touches can trigger the\n * context menu on mobile devices. When the context menu appears after a touch,\n * the mode will still be considered \"touch\" instead of swapping to mouse.\n *\n * @param touchTimeout This is the amount of time that can occur between a\n * touchstart and mousemove event but still be considered part of a \"touch\" user\n * mode. This should probably be kept at the default value, but if the touch\n * mode isn't updating as you would expect, you can try increasing or decreasing\n * this value until it does.\n * @return true if the app is in touch mode.\n * @private\n */\nexport default function useTouchDetection(touchTimeout) {\n    if (touchTimeout === void 0) { touchTimeout = DEFAULT_TOUCH_TIMEOUT; }\n    var _a = useState(0), lastTouchTime = _a[0], setTouchTime = _a[1];\n    var touchRef = useRefCache(lastTouchTime);\n    var contextMenuRef = useRef(false);\n    var updateTouchTime = useCallback(function () {\n        setTouchTime(Date.now());\n        contextMenuRef.current = false;\n    }, []);\n    var resetTouchTime = useCallback(function () {\n        var lastTouchTime = touchRef.current;\n        if (contextMenuRef.current || Date.now() - lastTouchTime < touchTimeout) {\n            contextMenuRef.current = false;\n            return;\n        }\n        setTouchTime(0);\n        // disabled since useRefCache for touchRef\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [touchTimeout]);\n    useEffect(function () {\n        window.addEventListener(\"touchstart\", updateTouchTime, true);\n        return function () {\n            window.removeEventListener(\"touchstart\", updateTouchTime, true);\n        };\n    }, [updateTouchTime]);\n    useEffect(function () {\n        if (lastTouchTime === 0) {\n            contextMenuRef.current = false;\n            return;\n        }\n        var updateContextMenu = function () {\n            contextMenuRef.current = true;\n        };\n        window.addEventListener(\"mousemove\", resetTouchTime, true);\n        window.addEventListener(\"contextmenu\", updateContextMenu, true);\n        return function () {\n            window.removeEventListener(\"mousemove\", resetTouchTime, true);\n            window.removeEventListener(\"contextmenu\", updateContextMenu, true);\n        };\n    }, [lastTouchTime, resetTouchTime]);\n    return lastTouchTime !== 0;\n}\n//# sourceMappingURL=useTouchDetection.js.map"]},"metadata":{},"sourceType":"module"}