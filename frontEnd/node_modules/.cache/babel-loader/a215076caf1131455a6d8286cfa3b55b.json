{"ast":null,"code":"import { useEffect, useMemo } from \"react\";\nimport { useNestedDialogContext } from \"./NestedDialogContext\";\n/**\n * This hook is used to fix the nested overlays and the escape keypress when multiple\n * dialogs are rendered at the same time on a page. All it really does is keep a stack\n * of the dialog ids that are current visible. If there is more than 1 dialog visible\n * and the dialog is not at the top of the stack, the overlay and escape keypress will\n * be disabled.\n *\n * NOTE: This will not work if you nest dialogs together and have them become visible at\n * the same time because the ids will get added from child -> parent instead of parent -> child.\n * This flow shouldn't really happen though so it isn't planned on being fixed.\n */\n\nexport default function useNestedDialogFixes(_a) {\n  var id = _a.id,\n      visible = _a.visible,\n      disabled = _a.disabled,\n      propDisableEscapeClose = _a.disableEscapeClose;\n\n  var _b = useNestedDialogContext(),\n      add = _b.add,\n      remove = _b.remove,\n      stack = _b.stack;\n\n  useEffect(function () {\n    if (disabled || !visible) {\n      return;\n    }\n\n    add(id);\n    return function () {\n      remove(id);\n    };\n  }, [visible, disabled, id, add, remove]);\n  return useMemo(function () {\n    var disableOverlay = false;\n    var disableEscapeClose = propDisableEscapeClose;\n\n    if (!disabled && visible && stack.length > 1) {\n      var lastIndex = stack.length - 1;\n      var i = stack.findIndex(function (dialogId) {\n        return id === dialogId;\n      });\n      disableOverlay = i < lastIndex;\n\n      if (!propDisableEscapeClose) {\n        disableEscapeClose = i < lastIndex;\n      }\n    }\n\n    return {\n      disableOverlay: disableOverlay,\n      disableEscapeClose: disableEscapeClose\n    };\n  }, [id, propDisableEscapeClose, disabled, visible, stack]);\n}","map":{"version":3,"sources":["../src/useNestedDialogFixes.ts"],"names":[],"mappings":"AAAA,SAAS,SAAT,EAAoB,OAApB,QAAmC,OAAnC;AACA,SAAS,sBAAT,QAAuC,uBAAvC;AAcA;;;;;;;;;;;;AAWA,eAAc,SAAU,oBAAV,CAA+B,EAA/B,EAKJ;MAJR,EAAE,GAAA,EAAA,CAAA,E;MACF,OAAO,GAAA,EAAA,CAAA,O;MACP,QAAQ,GAAA,EAAA,CAAA,Q;MACY,sBAAsB,GAAA,EAAA,CAAA,kB;;AAEpC,MAAA,EAAA,GAAyB,sBAAsB,EAA/C;AAAA,MAAE,GAAG,GAAA,EAAA,CAAA,GAAL;AAAA,MAAO,MAAM,GAAA,EAAA,CAAA,MAAb;AAAA,MAAe,KAAK,GAAA,EAAA,CAAA,KAApB;;AACN,EAAA,SAAS,CAAC,YAAA;AACR,QAAI,QAAQ,IAAI,CAAC,OAAjB,EAA0B;AACxB;AACD;;AAED,IAAA,GAAG,CAAC,EAAD,CAAH;AACA,WAAO,YAAA;AACL,MAAA,MAAM,CAAC,EAAD,CAAN;AACD,KAFD;AAGD,GATQ,EASN,CAAC,OAAD,EAAU,QAAV,EAAoB,EAApB,EAAwB,GAAxB,EAA6B,MAA7B,CATM,CAAT;AAWA,SAAO,OAAO,CAAC,YAAA;AACb,QAAI,cAAc,GAAG,KAArB;AACA,QAAI,kBAAkB,GAAG,sBAAzB;;AACA,QAAI,CAAC,QAAD,IAAa,OAAb,IAAwB,KAAK,CAAC,MAAN,GAAe,CAA3C,EAA8C;AAC5C,UAAM,SAAS,GAAG,KAAK,CAAC,MAAN,GAAe,CAAjC;AACA,UAAM,CAAC,GAAG,KAAK,CAAC,SAAN,CAAgB,UAAC,QAAD,EAAS;AAAK,eAAA,EAAE,KAAF,QAAA;AAAe,OAA7C,CAAV;AACA,MAAA,cAAc,GAAG,CAAC,GAAG,SAArB;;AACA,UAAI,CAAC,sBAAL,EAA6B;AAC3B,QAAA,kBAAkB,GAAG,CAAC,GAAG,SAAzB;AACD;AACF;;AAED,WAAO;AACL,MAAA,cAAc,EAAA,cADT;AAEL,MAAA,kBAAkB,EAAA;AAFb,KAAP;AAID,GAhBa,EAgBX,CAAC,EAAD,EAAK,sBAAL,EAA6B,QAA7B,EAAuC,OAAvC,EAAgD,KAAhD,CAhBW,CAAd;AAiBD","sourceRoot":"","sourcesContent":["import { useEffect, useMemo } from \"react\";\nimport { useNestedDialogContext } from \"./NestedDialogContext\";\n/**\n * This hook is used to fix the nested overlays and the escape keypress when multiple\n * dialogs are rendered at the same time on a page. All it really does is keep a stack\n * of the dialog ids that are current visible. If there is more than 1 dialog visible\n * and the dialog is not at the top of the stack, the overlay and escape keypress will\n * be disabled.\n *\n * NOTE: This will not work if you nest dialogs together and have them become visible at\n * the same time because the ids will get added from child -> parent instead of parent -> child.\n * This flow shouldn't really happen though so it isn't planned on being fixed.\n */\nexport default function useNestedDialogFixes(_a) {\n    var id = _a.id, visible = _a.visible, disabled = _a.disabled, propDisableEscapeClose = _a.disableEscapeClose;\n    var _b = useNestedDialogContext(), add = _b.add, remove = _b.remove, stack = _b.stack;\n    useEffect(function () {\n        if (disabled || !visible) {\n            return;\n        }\n        add(id);\n        return function () {\n            remove(id);\n        };\n    }, [visible, disabled, id, add, remove]);\n    return useMemo(function () {\n        var disableOverlay = false;\n        var disableEscapeClose = propDisableEscapeClose;\n        if (!disabled && visible && stack.length > 1) {\n            var lastIndex = stack.length - 1;\n            var i = stack.findIndex(function (dialogId) { return id === dialogId; });\n            disableOverlay = i < lastIndex;\n            if (!propDisableEscapeClose) {\n                disableEscapeClose = i < lastIndex;\n            }\n        }\n        return {\n            disableOverlay: disableOverlay,\n            disableEscapeClose: disableEscapeClose,\n        };\n    }, [id, propDisableEscapeClose, disabled, visible, stack]);\n}\n//# sourceMappingURL=useNestedDialogFixes.js.map"]},"metadata":{},"sourceType":"module"}