{"ast":null,"code":"import { useCallback, useEffect, useRef } from \"react\";\nimport { useRefCache, useTimeout } from \"@react-md/utils\";\nimport { useTooltipHoverModeActions, useTooltipHoverModeDelay, useTooltipHoverModeEnabled } from \"./useTooltipHoverMode\";\n/**\n * This handles creating and returning the required mouse event listeners to\n * show and hide tooltips as needed. If there were any mouse event listeners\n * passed in, they will be merged with the tooltip logic automatically and\n * memoized.\n */\n\nexport function useMouseState(_a) {\n  var mode = _a.mode,\n      showTooltip = _a.showTooltip,\n      hideTooltip = _a.hideTooltip,\n      initiated = _a.initiated,\n      setInitiated = _a.setInitiated,\n      propDelay = _a.delay,\n      onMouseEnter = _a.onMouseEnter,\n      onMouseLeave = _a.onMouseLeave,\n      setEstimatedPosition = _a.setEstimatedPosition,\n      disableHoverMode = _a.disableHoverMode;\n  var handlers = useRefCache({\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave\n  });\n  var isHoverModeable = useTooltipHoverModeEnabled();\n\n  if (typeof disableHoverMode === \"boolean\") {\n    isHoverModeable = !disableHoverMode;\n  }\n\n  var delay = useTooltipHoverModeDelay();\n\n  if (!isHoverModeable) {\n    delay = propDelay;\n  }\n\n  var hoverModeActions = useTooltipHoverModeActions();\n\n  var _b = useTimeout(function () {\n    if (initiated.current === \"mouse\") {\n      showTooltip();\n\n      if (isHoverModeable) {\n        hoverModeActions.enable();\n      }\n    }\n  }, delay),\n      start = _b[0],\n      stop = _b[1];\n\n  var handleMouseEnter = useCallback(function (event) {\n    var onMouseEnter = handlers.current.onMouseEnter;\n\n    if (onMouseEnter) {\n      onMouseEnter(event);\n    }\n\n    if (initiated.current !== null) {\n      return;\n    }\n\n    setInitiated(\"mouse\");\n    setEstimatedPosition(event.currentTarget);\n    start();\n  }, [setEstimatedPosition, setInitiated, start, handlers, initiated]);\n  var handleMouseLeave = useCallback(function (event) {\n    var onMouseLeave = handlers.current.onMouseLeave;\n\n    if (onMouseLeave) {\n      onMouseLeave(event);\n    }\n\n    if (initiated.current !== \"mouse\") {\n      return;\n    }\n\n    stop();\n    hideTooltip();\n\n    if (isHoverModeable) {\n      hoverModeActions.startDisableTimer();\n    }\n  }, [isHoverModeable, handlers, hideTooltip, hoverModeActions, initiated, stop]);\n  return [stop, mode !== \"touch\" ? handleMouseEnter : onMouseEnter, mode !== \"touch\" ? handleMouseLeave : onMouseLeave];\n}\n/**\n * This handles creating and returning the required keyboard event listeners to\n * show and hide tooltips as needed. If there were any keyboard event listeners\n * passed in, they will be merged with the tooltip logic automatically and\n * memoized.\n */\n\nexport function useKeyboardState(_a) {\n  var mode = _a.mode,\n      showTooltip = _a.showTooltip,\n      hideTooltip = _a.hideTooltip,\n      delay = _a.delay,\n      initiated = _a.initiated,\n      setInitiated = _a.setInitiated,\n      onFocus = _a.onFocus,\n      onBlur = _a.onBlur,\n      onKeyDown = _a.onKeyDown,\n      setEstimatedPosition = _a.setEstimatedPosition;\n  var handlers = useRefCache({\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onKeyDown: onKeyDown\n  });\n  var isWindowBlurred = useRef(false);\n\n  var _b = useTimeout(function () {\n    if (initiated.current === \"keyboard\") {\n      showTooltip();\n    }\n  }, delay),\n      start = _b[0],\n      stop = _b[1];\n\n  var handleFocus = useCallback(function (event) {\n    var onFocus = handlers.current.onFocus;\n\n    if (onFocus) {\n      onFocus(event);\n    } // if the entire browser window was blurred, we don't want to show the\n    // tooltip on the next focus event since it is confusing to see a tooltip\n    // appear again after re-focusing a window.\n\n\n    if (isWindowBlurred.current) {\n      isWindowBlurred.current = false;\n      return;\n    }\n\n    setInitiated(\"keyboard\");\n    setEstimatedPosition(event.currentTarget);\n    start();\n  }, // disabled since useRefCache for handlers\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [setEstimatedPosition, setInitiated, start]);\n  var handleBlur = useCallback(function (event) {\n    var onBlur = handlers.current.onBlur;\n\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    stop();\n    hideTooltip();\n  }, // disabled since useRefCache for handlers\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [hideTooltip, stop]);\n  var handleKeyDown = useCallback(function (event) {\n    var onKeyDown = handlers.current.onKeyDown;\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n\n    if (initiated.current === \"keyboard\" && event.key === \"Escape\") {\n      stop();\n      hideTooltip();\n    }\n  }, // disabled since both initiated and handlers are refs\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [hideTooltip, stop]);\n  useEffect(function () {\n    if (mode !== \"keyboard\") {\n      return;\n    } // whenever the browser loses focus, need to ensure that when the browser is\n    // re-focused the last focused element (that had a tooltip) does not make\n    // the tooltip appear\n\n\n    var handleWindowBlur = function () {\n      if (document.hidden) {\n        isWindowBlurred.current = true;\n        hideTooltip();\n      } else {\n        window.requestAnimationFrame(function () {\n          isWindowBlurred.current = false;\n        });\n      }\n    };\n\n    window.addEventListener(\"visibilitychange\", handleWindowBlur);\n    return function () {\n      window.removeEventListener(\"visibilitychange\", handleWindowBlur);\n    };\n  }, [mode, hideTooltip]);\n  return [stop, mode === \"keyboard\" ? handleFocus : onFocus, mode === \"keyboard\" ? handleBlur : onBlur, mode === \"keyboard\" ? handleKeyDown : onKeyDown];\n}\n/**\n * This handles creating and returning the required touch event listeners to\n * show and hide tooltips as needed. If there were any touch event listeners\n * passed in, they will be merged with the tooltip logic automatically and\n * memoized.\n *\n * Tooltips on touch devices are a bit different than mouse and keyboard. Since\n * tooltips appear after a long press on mobile and long presses on mobile cause\n * a context menu to appear, no timeouts for showing the tooltip are started\n * after a touchstart event.  The tooltip will only appear after a contextmenu\n * event which has the default behavior prevented so the tooltip appears\n * instead. After the tooltip appears, it will stay visible as long as the user\n * keeps their finger on their phone. Once they remove their finger, the tooltip\n * will be visible for another `x`ms to make it easier to read without their\n * finger in the way and finally hide.\n */\n\nexport function useTouchState(_a) {\n  var mode = _a.mode,\n      visible = _a.visible,\n      showTooltip = _a.showTooltip,\n      hideTooltip = _a.hideTooltip,\n      delay = _a.delay,\n      setInitiated = _a.setInitiated,\n      onTouchStart = _a.onTouchStart,\n      onTouchMove = _a.onTouchMove,\n      onContextMenu = _a.onContextMenu,\n      setEstimatedPosition = _a.setEstimatedPosition;\n  var touched = useRef(false);\n  var handlers = useRefCache({\n    onTouchStart: onTouchStart,\n    onTouchMove: onTouchMove,\n    onContextMenu: onContextMenu\n  });\n\n  var _b = useTimeout(function () {\n    touched.current = false;\n    hideTooltip();\n  }, delay),\n      start = _b[0],\n      stop = _b[1];\n\n  useEffect(function () {\n    if (!visible) {\n      return;\n    }\n\n    if (mode !== \"touch\") {\n      touched.current = false;\n      return;\n    }\n\n    var cb = function () {\n      start();\n      window.removeEventListener(\"touchend\", cb, true);\n    };\n\n    window.addEventListener(\"touchend\", cb, true);\n    return function () {\n      window.removeEventListener(\"touchend\", cb, true);\n    }; // disabled since it should only be updated on visible or touch changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [visible, mode]);\n  var handleTouchStart = useCallback(function (event) {\n    var onTouchStart = handlers.current.onTouchStart;\n\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    touched.current = true;\n    stop();\n    setEstimatedPosition(event.currentTarget);\n  }, // disabled since useRefCache for handlers\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [setEstimatedPosition, stop]);\n  var handleTouchMove = useCallback(function (event) {\n    var onTouchMove = handlers.current.onTouchMove;\n\n    if (onTouchMove) {\n      onTouchMove(event);\n    }\n\n    touched.current = false;\n  }, // disabled since useRefCache for handlers\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var handleContextMenu = useCallback(function (event) {\n    var onContextMenu = handlers.current.onContextMenu;\n\n    if (onContextMenu) {\n      onContextMenu(event);\n    }\n\n    if (!touched.current) {\n      return;\n    } // need to prevent the context menu from appearing and instead show the tooltip\n\n\n    event.preventDefault(); // since the context menu might also select text by default, we want to deselect any\n    // selected text if it is within the container element\n\n    var selection = window.getSelection();\n    var selectionNode = selection && selection.anchorNode && selection.anchorNode.parentElement;\n\n    if (selection && selectionNode && event.currentTarget.contains(selectionNode)) {\n      selection.empty();\n    }\n\n    setInitiated(\"touch\");\n    showTooltip();\n  }, // disabled since useRefCache for handlers\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [setInitiated, showTooltip]);\n  return [stop, handleTouchStart, handleTouchMove, mode === \"touch\" ? handleContextMenu : onContextMenu];\n}","map":{"version":3,"sources":["../src/useHandlers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useCallback, useEffect, useRef, } from \"react\";\nimport { useRefCache, useTimeout } from \"@react-md/utils\";\nimport { useTooltipHoverModeActions, useTooltipHoverModeDelay, useTooltipHoverModeEnabled, } from \"./useTooltipHoverMode\";\n/**\n * This handles creating and returning the required mouse event listeners to\n * show and hide tooltips as needed. If there were any mouse event listeners\n * passed in, they will be merged with the tooltip logic automatically and\n * memoized.\n */\nexport function useMouseState(_a) {\n    var mode = _a.mode, showTooltip = _a.showTooltip, hideTooltip = _a.hideTooltip, initiated = _a.initiated, setInitiated = _a.setInitiated, propDelay = _a.delay, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, setEstimatedPosition = _a.setEstimatedPosition, disableHoverMode = _a.disableHoverMode;\n    var handlers = useRefCache({ onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave });\n    var isHoverModeable = useTooltipHoverModeEnabled();\n    if (typeof disableHoverMode === \"boolean\") {\n        isHoverModeable = !disableHoverMode;\n    }\n    var delay = useTooltipHoverModeDelay();\n    if (!isHoverModeable) {\n        delay = propDelay;\n    }\n    var hoverModeActions = useTooltipHoverModeActions();\n    var _b = useTimeout(function () {\n        if (initiated.current === \"mouse\") {\n            showTooltip();\n            if (isHoverModeable) {\n                hoverModeActions.enable();\n            }\n        }\n    }, delay), start = _b[0], stop = _b[1];\n    var handleMouseEnter = useCallback(function (event) {\n        var onMouseEnter = handlers.current.onMouseEnter;\n        if (onMouseEnter) {\n            onMouseEnter(event);\n        }\n        if (initiated.current !== null) {\n            return;\n        }\n        setInitiated(\"mouse\");\n        setEstimatedPosition(event.currentTarget);\n        start();\n    }, [setEstimatedPosition, setInitiated, start, handlers, initiated]);\n    var handleMouseLeave = useCallback(function (event) {\n        var onMouseLeave = handlers.current.onMouseLeave;\n        if (onMouseLeave) {\n            onMouseLeave(event);\n        }\n        if (initiated.current !== \"mouse\") {\n            return;\n        }\n        stop();\n        hideTooltip();\n        if (isHoverModeable) {\n            hoverModeActions.startDisableTimer();\n        }\n    }, [isHoverModeable, handlers, hideTooltip, hoverModeActions, initiated, stop]);\n    return [\n        stop,\n        mode !== \"touch\" ? handleMouseEnter : onMouseEnter,\n        mode !== \"touch\" ? handleMouseLeave : onMouseLeave,\n    ];\n}\n/**\n * This handles creating and returning the required keyboard event listeners to\n * show and hide tooltips as needed. If there were any keyboard event listeners\n * passed in, they will be merged with the tooltip logic automatically and\n * memoized.\n */\nexport function useKeyboardState(_a) {\n    var mode = _a.mode, showTooltip = _a.showTooltip, hideTooltip = _a.hideTooltip, delay = _a.delay, initiated = _a.initiated, setInitiated = _a.setInitiated, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, setEstimatedPosition = _a.setEstimatedPosition;\n    var handlers = useRefCache({ onFocus: onFocus, onBlur: onBlur, onKeyDown: onKeyDown });\n    var isWindowBlurred = useRef(false);\n    var _b = useTimeout(function () {\n        if (initiated.current === \"keyboard\") {\n            showTooltip();\n        }\n    }, delay), start = _b[0], stop = _b[1];\n    var handleFocus = useCallback(function (event) {\n        var onFocus = handlers.current.onFocus;\n        if (onFocus) {\n            onFocus(event);\n        }\n        // if the entire browser window was blurred, we don't want to show the\n        // tooltip on the next focus event since it is confusing to see a tooltip\n        // appear again after re-focusing a window.\n        if (isWindowBlurred.current) {\n            isWindowBlurred.current = false;\n            return;\n        }\n        setInitiated(\"keyboard\");\n        setEstimatedPosition(event.currentTarget);\n        start();\n    }, \n    // disabled since useRefCache for handlers\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [setEstimatedPosition, setInitiated, start]);\n    var handleBlur = useCallback(function (event) {\n        var onBlur = handlers.current.onBlur;\n        if (onBlur) {\n            onBlur(event);\n        }\n        stop();\n        hideTooltip();\n    }, \n    // disabled since useRefCache for handlers\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [hideTooltip, stop]);\n    var handleKeyDown = useCallback(function (event) {\n        var onKeyDown = handlers.current.onKeyDown;\n        if (onKeyDown) {\n            onKeyDown(event);\n        }\n        if (initiated.current === \"keyboard\" && event.key === \"Escape\") {\n            stop();\n            hideTooltip();\n        }\n    }, \n    // disabled since both initiated and handlers are refs\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [hideTooltip, stop]);\n    useEffect(function () {\n        if (mode !== \"keyboard\") {\n            return;\n        }\n        // whenever the browser loses focus, need to ensure that when the browser is\n        // re-focused the last focused element (that had a tooltip) does not make\n        // the tooltip appear\n        var handleWindowBlur = function () {\n            if (document.hidden) {\n                isWindowBlurred.current = true;\n                hideTooltip();\n            }\n            else {\n                window.requestAnimationFrame(function () {\n                    isWindowBlurred.current = false;\n                });\n            }\n        };\n        window.addEventListener(\"visibilitychange\", handleWindowBlur);\n        return function () {\n            window.removeEventListener(\"visibilitychange\", handleWindowBlur);\n        };\n    }, [mode, hideTooltip]);\n    return [\n        stop,\n        mode === \"keyboard\" ? handleFocus : onFocus,\n        mode === \"keyboard\" ? handleBlur : onBlur,\n        mode === \"keyboard\" ? handleKeyDown : onKeyDown,\n    ];\n}\n/**\n * This handles creating and returning the required touch event listeners to\n * show and hide tooltips as needed. If there were any touch event listeners\n * passed in, they will be merged with the tooltip logic automatically and\n * memoized.\n *\n * Tooltips on touch devices are a bit different than mouse and keyboard. Since\n * tooltips appear after a long press on mobile and long presses on mobile cause\n * a context menu to appear, no timeouts for showing the tooltip are started\n * after a touchstart event.  The tooltip will only appear after a contextmenu\n * event which has the default behavior prevented so the tooltip appears\n * instead. After the tooltip appears, it will stay visible as long as the user\n * keeps their finger on their phone. Once they remove their finger, the tooltip\n * will be visible for another `x`ms to make it easier to read without their\n * finger in the way and finally hide.\n */\nexport function useTouchState(_a) {\n    var mode = _a.mode, visible = _a.visible, showTooltip = _a.showTooltip, hideTooltip = _a.hideTooltip, delay = _a.delay, setInitiated = _a.setInitiated, onTouchStart = _a.onTouchStart, onTouchMove = _a.onTouchMove, onContextMenu = _a.onContextMenu, setEstimatedPosition = _a.setEstimatedPosition;\n    var touched = useRef(false);\n    var handlers = useRefCache({ onTouchStart: onTouchStart, onTouchMove: onTouchMove, onContextMenu: onContextMenu });\n    var _b = useTimeout(function () {\n        touched.current = false;\n        hideTooltip();\n    }, delay), start = _b[0], stop = _b[1];\n    useEffect(function () {\n        if (!visible) {\n            return;\n        }\n        if (mode !== \"touch\") {\n            touched.current = false;\n            return;\n        }\n        var cb = function () {\n            start();\n            window.removeEventListener(\"touchend\", cb, true);\n        };\n        window.addEventListener(\"touchend\", cb, true);\n        return function () {\n            window.removeEventListener(\"touchend\", cb, true);\n        };\n        // disabled since it should only be updated on visible or touch changes\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [visible, mode]);\n    var handleTouchStart = useCallback(function (event) {\n        var onTouchStart = handlers.current.onTouchStart;\n        if (onTouchStart) {\n            onTouchStart(event);\n        }\n        touched.current = true;\n        stop();\n        setEstimatedPosition(event.currentTarget);\n    }, \n    // disabled since useRefCache for handlers\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [setEstimatedPosition, stop]);\n    var handleTouchMove = useCallback(function (event) {\n        var onTouchMove = handlers.current.onTouchMove;\n        if (onTouchMove) {\n            onTouchMove(event);\n        }\n        touched.current = false;\n    }, \n    // disabled since useRefCache for handlers\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    var handleContextMenu = useCallback(function (event) {\n        var onContextMenu = handlers.current.onContextMenu;\n        if (onContextMenu) {\n            onContextMenu(event);\n        }\n        if (!touched.current) {\n            return;\n        }\n        // need to prevent the context menu from appearing and instead show the tooltip\n        event.preventDefault();\n        // since the context menu might also select text by default, we want to deselect any\n        // selected text if it is within the container element\n        var selection = window.getSelection();\n        var selectionNode = selection && selection.anchorNode && selection.anchorNode.parentElement;\n        if (selection &&\n            selectionNode &&\n            event.currentTarget.contains(selectionNode)) {\n            selection.empty();\n        }\n        setInitiated(\"touch\");\n        showTooltip();\n    }, \n    // disabled since useRefCache for handlers\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [setInitiated, showTooltip]);\n    return [\n        stop,\n        handleTouchStart,\n        handleTouchMove,\n        mode === \"touch\" ? handleContextMenu : onContextMenu,\n    ];\n}\n//# sourceMappingURL=useHandlers.js.map"]},"metadata":{},"sourceType":"module"}